<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<head><title>2024-01-31 The Micron Programming Language Specification</title>
<style type="text/css" media="screen, projection, print">
body{font-family:Arial,sans-serif;font-size:small;orphans:2;widows:2;}
h1,h2,h3,h4{background-color:#F5F5F5;padding:0.3em;page-break-after:avoid;margin:0;border-style:solid;border-color:white #F5F5F5 #F5F5F5 #F5F5F5;border-width:thin;}
span.label{position:absolute;top:auto;left:0;margin-top:0.2em;font-size:smaller;color:darkblue; }
span.ident{background-color:aliceblue;font-weight:bold;padding:0 0.2em 0 0.2em;}
a[href^="#"]{text-decoration:none;font-weight:normal;color:darkblue;background-color:#F5F5F5;}
div{border-style:none solid solid solid;border-width:thin;border-color:#F5F5F5;margin:0;padding:0.3em;}
ol,ul{margin:0;}
</style>
</head><body>
<h4 style="margin-left:9px"><span class="label"><a name="14061">1</a></span>
Front Matter</h4>
<h4 style="margin-left:27px"><span class="label"><a name="14062">1.1</a></span>
Title</h4>
<div style="margin-left:45px"><span class="label"><a name="14063">1.1.1</a></span>
The Micron Programming Language Specification</div>
<h4 style="margin-left:27px"><span class="label"><a name="14064">1.2</a></span>
Version</h4>
<div style="margin-left:45px"><span class="label"><a name="14065">1.2.1</a></span>
2024-12-17, work in progress</div>
<h4 style="margin-left:27px"><span class="label"><a name="14066">1.3</a></span>
Author</h4>
<div style="margin-left:45px"><span class="label"><a name="14067">1.3.1</a></span>
me@rochus-keller.ch</div>
<h4 style="margin-left:27px"><span class="label"><a name="14787">1.4</a></span>
License</h4>
<div style="margin-left:45px"><span class="label"><a name="14788">1.4.1</a></span>
This file may be used under the terms of the GNU General Public License (GPL) versions 2.0 or 3.0 as published by the Free Software Foundation and appearing in the file LICENSE.GPL included in the packaging of this file. Please review the following information to ensure GNU General Public Licensing requirements will be met: http://www.fsf.org/licensing/licenses/info/GPLv2.html and http://www.gnu.org/copyleft/gpl.html.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14068">1.5</a></span>
<b>Additional Credits</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14070">1.5.1</a></span>
A lot of text is derived from the Oberon+ language specification <a href="#14631"><b>[OBX]</b></a>, which again is derived from the Oberon-2 language specification <a href="#14630"><b>[Mo91]</b></a>.</div>
<div style="margin-left:45px"><span class="label"><a name="14071">1.5.2</a></span>
This specification was written in CrossLine (see <a href="https://github.com/rochus-keller/CrossLine"><u>github.com/.../CrossLine</u></a>)</div>
<h4 style="margin-left:27px"><span class="label"><a name="14072">1.6</a></span>
<b>Table of Contents</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14693">1.6.1</a></span>
<a href="#14061">1 Front Matter</a></div>
<div style="margin-left:45px"><span class="label"><a name="14699">1.6.2</a></span>
<a href="#14060">2 Language Specification</a></div>
<div style="margin-left:63px"><span class="label"><a name="14700">1.6.2.1</a></span>
<a href="#14125">2.1 Introduction</a></div>
<div style="margin-left:63px"><span class="label"><a name="14702">1.6.2.2</a></span>
<a href="#14127">2.2 Syntax</a></div>
<div style="margin-left:63px"><span class="label"><a name="14703">1.6.2.3</a></span>
<a href="#14126">2.3 Vocabulary and Representation</a></div>
<div style="margin-left:81px"><span class="label"><a name="14704">1.6.2.3.1</a></span>
<a href="#14168">2.3.4 Identifiers</a></div>
<div style="margin-left:81px"><span class="label"><a name="14705">1.6.2.3.2</a></span>
<a href="#14174">2.3.5 Numbers</a></div>
<div style="margin-left:81px"><span class="label"><a name="14706">1.6.2.3.3</a></span>
<a href="#14181">2.3.6 Characters</a></div>
<div style="margin-left:81px"><span class="label"><a name="14707">1.6.2.3.4</a></span>
<a href="#14186">2.3.7 Strings</a></div>
<div style="margin-left:81px"><span class="label"><a name="14709">1.6.2.3.5</a></span>
<a href="#14198">2.3.8 Operators and Delimiters</a></div>
<div style="margin-left:81px"><span class="label"><a name="14710">1.6.2.3.6</a></span>
<a href="#14201">2.3.9 Reserved Words</a></div>
<div style="margin-left:81px"><span class="label"><a name="14711">1.6.2.3.7</a></span>
<a href="#14204">2.3.10 Comments</a></div>
<div style="margin-left:63px"><span class="label"><a name="14712">1.6.2.4</a></span>
<a href="#14160">2.4 Declarations and scope rules</a></div>
<div style="margin-left:63px"><span class="label"><a name="14713">1.6.2.5</a></span>
<a href="#14210">2.5 Constant declarations</a></div>
<div style="margin-left:63px"><span class="label"><a name="14714">1.6.2.6</a></span>
<a href="#14218">2.6 Type declarations</a></div>
<div style="margin-left:81px"><span class="label"><a name="14715">1.6.2.6.1</a></span>
<a href="#14224">2.6.4 Basic types</a></div>
<div style="margin-left:81px"><span class="label"><a name="14716">1.6.2.6.2</a></span>
<a href="#14257">2.6.5 Array types</a></div>
<div style="margin-left:81px"><span class="label"><a name="14717">1.6.2.6.3</a></span>
<a href="#14270">2.6.6 Record types</a></div>
<div style="margin-left:81px"><span class="label"><a name="14718">1.6.2.6.4</a></span>
<a href="#14278">2.6.7 Pointer types</a></div>
<div style="margin-left:81px"><span class="label"><a name="14719">1.6.2.6.5</a></span>
<a href="#14285">2.6.8 Procedure types</a></div>
<div style="margin-left:81px"><span class="label"><a name="14720">1.6.2.6.6</a></span>
<a href="#14291">2.6.9 Enumeration types</a></div>
<div style="margin-left:81px"><span class="label"><a name="15367">1.6.2.6.7</a></span>
<a href="#15364">2.6.10 Alias types</a></div>
<div style="margin-left:63px"><span class="label"><a name="14721">1.6.2.7</a></span>
<a href="#14298">2.7 Variable declarations</a></div>
<div style="margin-left:63px"><span class="label"><a name="14722">1.6.2.8</a></span>
<a href="#14304">2.8 Expressions</a></div>
<div style="margin-left:81px"><span class="label"><a name="14723">1.6.2.8.1</a></span>
<a href="#14306">2.8.2 Operands</a></div>
<div style="margin-left:81px"><span class="label"><a name="14724">1.6.2.8.2</a></span>
<a href="#14322">2.8.3 Operators</a></div>
<div style="margin-left:99px"><span class="label"><a name="14725">1.6.2.8.2.1</a></span>
<a href="#14325">2.8.3.3 Logical operators</a></div>
<div style="margin-left:99px"><span class="label"><a name="14726">1.6.2.8.2.2</a></span>
<a href="#14328">2.8.3.4 Arithmetic operators</a></div>
<div style="margin-left:99px"><span class="label"><a name="14727">1.6.2.8.2.3</a></span>
<a href="#14335">2.8.3.5 Set Operators</a></div>
<div style="margin-left:99px"><span class="label"><a name="14728">1.6.2.8.2.4</a></span>
<a href="#14339">2.8.3.6 Relations</a></div>
<div style="margin-left:99px"><span class="label"><a name="14729">1.6.2.8.2.5</a></span>
<a href="#14344">2.8.3.7 String operators</a></div>
<div style="margin-left:99px"><span class="label"><a name="14730">1.6.2.8.2.6</a></span>
<a href="#14662">2.8.3.8 Address operator</a></div>
<div style="margin-left:99px"><span class="label"><a name="14731">1.6.2.8.2.7</a></span>
<a href="#14349">2.8.3.9 Function Call</a></div>
<div style="margin-left:81px"><span class="label"><a name="14732">1.6.2.8.3</a></span>
<a href="#14347">2.8.4 Constructors</a></div>
<div style="margin-left:63px"><span class="label"><a name="14733">1.6.2.9</a></span>
<a href="#14355">2.9 Statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14734">1.6.2.9.1</a></span>
<a href="#14359">2.9.3 Statement sequences</a></div>
<div style="margin-left:81px"><span class="label"><a name="14735">1.6.2.9.2</a></span>
<a href="#14447">2.9.4 Statement block</a></div>
<div style="margin-left:81px"><span class="label"><a name="14736">1.6.2.9.3</a></span>
<a href="#14363">2.9.5 Assignments</a></div>
<div style="margin-left:81px"><span class="label"><a name="14737">1.6.2.9.4</a></span>
<a href="#14374">2.9.6 Procedure calls</a></div>
<div style="margin-left:81px"><span class="label"><a name="14738">1.6.2.9.5</a></span>
<a href="#14381">2.9.7 If statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14739">1.6.2.9.6</a></span>
<a href="#14387">2.9.8 Case statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14740">1.6.2.9.7</a></span>
<a href="#14393">2.9.9 While statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14741">1.6.2.9.8</a></span>
<a href="#14400">2.9.10 Repeat statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14742">1.6.2.9.9</a></span>
<a href="#14404">2.9.11 For statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14743">1.6.2.9.10</a></span>
<a href="#14415">2.9.12 Loop statements</a></div>
<div style="margin-left:81px"><span class="label"><a name="14744">1.6.2.9.11</a></span>
<a href="#14422">2.9.13 Return, exit and goto statements</a></div>
<div style="margin-left:63px"><span class="label"><a name="14745">1.6.2.10</a></span>
<a href="#14434">2.10 Exception handling</a></div>
<div style="margin-left:63px"><span class="label"><a name="14746">1.6.2.11</a></span>
<a href="#14440">2.11 Procedure declarations</a></div>
<div style="margin-left:81px"><span class="label"><a name="14747">1.6.2.11.1</a></span>
<a href="#14458">2.11.12 Formal parameters</a></div>
<div style="margin-left:81px"><span class="label"><a name="14748">1.6.2.11.2</a></span>
<a href="#14493">2.11.13 Predeclared procedures</a></div>
<div style="margin-left:63px"><span class="label"><a name="14749">1.6.2.12</a></span>
<a href="#14498">2.12 Modules</a></div>
<div style="margin-left:63px"><span class="label"><a name="14750">1.6.2.13</a></span>
<a href="#14508">2.13 Generics</a></div>
<div style="margin-left:63px"><span class="label"><a name="14751">1.6.2.14</a></span>
<a href="#14514">2.14 Source code directives</a></div>
<div style="margin-left:81px"><span class="label"><a name="14752">1.6.2.14.1</a></span>
<a href="#14516">2.14.2 Configuration Variables</a></div>
<div style="margin-left:81px"><span class="label"><a name="14753">1.6.2.14.2</a></span>
<a href="#14525">2.14.3 Conditional compilation</a></div>
<div style="margin-left:45px"><span class="label"><a name="14754">1.6.3</a></span>
<a href="#14532">3 Definition of terms</a></div>
<div style="margin-left:45px"><span class="label"><a name="14769">1.6.4</a></span>
<a href="#14590">4 Complete Micron Syntax</a></div>
<div style="margin-left:45px"><span class="label"><a name="14770">1.6.5</a></span>
<a href="#14650">5 Predeclared Types</a></div>
<div style="margin-left:45px"><span class="label"><a name="14771">1.6.6</a></span>
<a href="#14136">6 Predeclared Procedure Reference</a></div>
<div style="margin-left:63px"><span class="label"><a name="14783">1.6.6.1</a></span>
<a href="#14775">6.1 Predeclared function procedures</a></div>
<div style="margin-left:63px"><span class="label"><a name="14784">1.6.6.2</a></span>
<a href="#14777">6.2 Predeclared proper procedures</a></div>
<div style="margin-left:45px"><span class="label"><a name="14772">1.6.7</a></span>
<a href="#14628">7 References</a></div>
<h4 style="margin-left:9px"><span class="label"><a name="14060">2</a></span>
<b>Language Specification</b></h4>
<h4 style="margin-left:27px"><span class="label"><a name="14125">2.1</a></span>
<b>Introduction</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14137">2.1.1</a></span>
Micron is a systems programming language with a syntax similar to Oberon+ and the flexibility of C. It is designed to be capable enough to represent the TBD (Lua, etc.) system, and thus to be an adequate alternative to C. </div>
<div style="margin-left:45px"><span class="label"><a name="14238">2.1.2</a></span>
The name &quot;Micron&quot; is an abbreviation of &quot;MicroOberon&quot;.</div>
<div style="margin-left:45px"><span class="label"><a name="14157">2.1.3</a></span>
The most important features of Micron are block structure, modularity, separate compilation, static typing with strong type checking, and generic programming.</div>
<div style="margin-left:45px"><span class="label"><a name="14158">2.1.4</a></span>
Like Oberon+, the language allows several simplifications compared to previous Oberon versions: reserved words can be written in lower case, all semicolons and commas are optional, and for some reserved words there are shorter variants; a declaration sequence can contain more than one CONST, TYPE and VAR section in arbitrary order, interleaved with procedures. </div>
<div style="margin-left:45px"><span class="label"><a name="14149">2.1.5</a></span>
INVAR and INLINE procedures, together with generic modules offer most of the capabilities of C preprocessor macros: running calculations at compile time, and substituting procedure calls by inline code, or creating code depending on compile time parametrization.</div>
<div style="margin-left:45px"><span class="label"><a name="14159">2.1.6</a></span>
The language is designed to work with a single-pass compiler. ABI compatibility with C on the target platform is assumed.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14227">2.1.7</a></span>
Main differences to Oberon+</h4>
<div style="margin-left:63px"><span class="label"><a name="14155">2.1.7.1</a></span>
In contrast to Oberon+, Micron has no garbage collector. Data allocated with NEW has to be explicitly deleted with DISPOSE.</div>
<div style="margin-left:63px"><span class="label"><a name="14228">2.1.7.2</a></span>
There is no type extension (inheritance). But record embedding (similar to Go) using the INLINE keyword is supported.</div>
<div style="margin-left:63px"><span class="label"><a name="14229">2.1.7.3</a></span>
A pointer can also point to basic types, enums and to objects on the stack, or to record fields or array elements.</div>
<div style="margin-left:63px"><span class="label"><a name="14230">2.1.7.4</a></span>
The address of an designated object can be taken with the @ operator and assigned to a pointer.</div>
<div style="margin-left:63px"><span class="label"><a name="14231">2.1.7.5</a></span>
INC and DEC can also be applied to pointers. The difference of two pointers can be calculated using ORD().</div>
<div style="margin-left:63px"><span class="label"><a name="14232">2.1.7.6</a></span>
There are no VAR parameters; instead a pointer to the variable has to be passed as a parameter.</div>
<div style="margin-left:63px"><span class="label"><a name="14233">2.1.7.7</a></span>
No DEFINITION modules; separate compilation fully depends on compiler-specific symbol files.</div>
<div style="margin-left:63px"><span class="label"><a name="14234">2.1.7.8</a></span>
No WCHAR type.</div>
<div style="margin-left:63px"><span class="label"><a name="14235">2.1.7.9</a></span>
Predeclared signed and unsigned types, INT8, UINT8, etc.; SIGNED() and UNSIGNED() cast built-in procedures.</div>
<div style="margin-left:63px"><span class="label"><a name="14481">2.1.7.10</a></span>
Integer literals are unsigned, and there are different suffix types.</div>
<div style="margin-left:63px"><span class="label"><a name="14236">2.1.7.11</a></span>
Only one-dimensional arrays (but array x of array y of T is still possible).</div>
<div style="margin-left:63px"><span class="label"><a name="14237">2.1.7.12</a></span>
There is a goto statement (mostly to easy porting existing C code).</div>
<div style="margin-left:63px"><span class="label"><a name="14353">2.1.7.13</a></span>
String concatenation only allowed for string and character literals.</div>
<div style="margin-left:63px"><span class="label"><a name="15417">2.1.7.14</a></span>
The WHILE statement has no ELSIF part in Micron.</div>
<div style="margin-left:63px"><span class="label"><a name="15425">2.1.7.15</a></span>
Procedure aliasses: collect all required types, constants and procedures in one module which is the interface of the shared library.</div>
<div style="margin-left:63px"><span class="label"><a name="15600">2.1.7.16</a></span>
Non-local access is not supported. Nested procedures only have access to the objects declared on module level, but not to declarations in the outer (nesting) procedures.</div>
<div style="margin-left:63px"><span class="label"><a name="15623">2.1.7.17</a></span>
The initial values of module and local variables are undefined in Micron.</div>
<div style="margin-left:63px"><span class="label"><a name="15630">2.1.7.18</a></span>
AND and NOT are supported in addition to &amp; and ~.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14127">2.2</a></span>
<a href=""><b>S</b></a><b>yntax</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14128">2.2.1</a></span>
An extended Backus-Naur Formalism (EBNF) is used to describe the syntax of Micron:</div>
<div style="margin-left:63px"><span class="label"><a name="14129">2.2.1.1</a></span>
Alternatives are separated by <b>|</b>.</div>
<div style="margin-left:63px"><span class="label"><a name="14130">2.2.1.2</a></span>
Brackets <b>[</b> and <b>]</b> denote optionality of the enclosed expression.</div>
<div style="margin-left:63px"><span class="label"><a name="14131">2.2.1.3</a></span>
Braces <b>{</b> and <b>}</b> denote its repetition (possibly 0 times).</div>
<div style="margin-left:63px"><span class="label"><a name="14132">2.2.1.4</a></span>
Syntactic entities (non-terminal symbols) are denoted by English words expressing their intuitive meaning.</div>
<div style="margin-left:63px"><span class="label"><a name="14133">2.2.1.5</a></span>
Symbols of the language vocabulary (terminal symbols) are denoted by strings formatted in bold face.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14126">2.3</a></span>
<b>Vocabulary and Representation</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14134">2.3.1</a></span>
Micron source code is a string of characters encoded using the UTF-8 variable-width encoding as defined in ISO/IEC 10646. </div>
<div style="margin-left:45px"><span class="label"><a name="16068">2.3.2</a></span>
Identifiers, numbers, operators, and delimiters are represented using the ASCII character set; strings and comments can use characters from the Latin-1 (as defined in ISO/IEC 8859-1) character set (UTF-8 encoded in the source code).</div>
<div style="margin-left:45px"><span class="label"><a name="14135">2.3.3</a></span>
The following lexical rules apply: blanks and line breaks must not occur within symbols (except in block comments, and blanks in strings); they are ignored unless they are essential to separate two consecutive symbols. Capital and lower-case letters are considered as distinct.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14168">2.3.4</a></span>
Identifiers</h4>
<div style="margin-left:63px"><span class="label"><a name="14169">2.3.4.1</a></span>
Identifiers are sequences of letters, digits and underscore. The first character must be a letter or an underscore. </div>
<div style="margin-left:63px"><span class="label"><a name="14170">2.3.4.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14171">2.3.4.2.1</a></span>
<pre><code>ident  = ( letter | '_' ) { letter | digit | '_' }</code></pre>
<pre><code>letter = 'A' ... 'Z' | 'a' ... 'z'</code></pre>
<pre><code>digit  = '0' ... '9'</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14172">2.3.4.3</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14173">2.3.4.3.1</a></span>
<pre><code>x</code></pre>
<pre><code>Scan</code></pre>
<pre><code>Oberon_2</code></pre>
<pre><code>_y</code></pre>
<pre><code>firstLetter</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14174">2.3.5</a></span>
Numbers</h4>
<div style="margin-left:63px"><span class="label"><a name="14175">2.3.5.1</a></span>
Number literals are integer or real constants. </div>
<div style="margin-left:63px"><span class="label"><a name="14464">2.3.5.2</a></span>
The type of an integer constant is the minimal unsigned integer type to which the constant value belongs (see  <a href="#14224">2.6.4 Basic types</a>). </div>
<div style="margin-left:63px"><span class="label"><a name="14463">2.3.5.3</a></span>
If the literal is specified with the suffix 'H', the representation is hexadecimal, if it is specified with suffix 'O', the representation is ocal, or if it is specified with suffic 'B', the representation is binary, otherwise the representation is decimal. </div>
<div style="margin-left:63px"><span class="label"><a name="14466">2.3.5.4</a></span>
The type of an integer constant can be explicitly set with a suffix. The U1, U2, U4 or U8 suffices correspond to the UINT8, UINT16, UINT32 or UINT64 unsigned integer types. The I1, I2, I4 or I8 suffices correspond to the INT8, INT16, INT32 or INT64 signed integer types. If the given constant value cannot be represented by the explicit type, the compiler reports an error. Alternatively, the suffix U or I can be used without explicit byte width, in which case the compiler assigns the minimal unsigned or signed integer type to which the value belongs.</div>
<div style="margin-left:63px"><span class="label"><a name="14469">2.3.5.5</a></span><span class="ident">NOTE</span>
Number literals can be prefixed with a sign. But the sign is not part of the literal, but of a simple expression including the literal, see <a href="#14322">2.8.3 Operators</a>. Use the SIGNED() predeclared function for a signed integer reinterpretation of the unsigned integer (e.g. SIGNED(0FFH) is an INT8 with value -1). Otherwise the term -0FFH becomes an INT16 with value -255.</div>
<div style="margin-left:63px"><span class="label"><a name="14470">2.3.5.6</a></span>
Signed integer types are represented in two’s complement form.</div>
<div style="margin-left:63px"><span class="label"><a name="14468">2.3.5.7</a></span>
A real number always contains a decimal point and at least one digit before the point. Optionally it may also contain a decimal scale factor. The letter 'E' means <i>times ten to the power of</i>. </div>
<div style="margin-left:63px"><span class="label"><a name="14467">2.3.5.8</a></span>
The type of a floating-point constant is the minimal <a href="#14539">Floating-point types</a> to which the constant value belongs.</div>
<div style="margin-left:63px"><span class="label"><a name="14176">2.3.5.9</a></span>
A real number is of type <code>LONGREAL</code>, if it has a scale factor containing the letter 'D', or of type <code>REAL</code>, if it has a scale factor containing the letter 'F'. If the scale factor contains the letter 'D', the type is <code>LONGREAL</code> if the mantissa or exponent are too large to be represented by <code>REAL</code>.</div>
<div style="margin-left:63px"><span class="label"><a name="15632">2.3.5.10</a></span>
Numbers can be interspersed with underscores for better readability, but the first character is always a digit.</div>
<div style="margin-left:63px"><span class="label"><a name="14177">2.3.5.11</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14178">2.3.5.11.1</a></span>
<pre><code>number   = integer | real</code></pre>
<pre><code>integer  = (digit {digit|'_'} ['O'|'B'] | digit {hexDigit|'_'} 'H')<br />           ['U'|'U1'|'U2'|'U4'|'U8'|'I'|'I1'|'I2'|'I4'|'I8']</code></pre>
<pre><code>real     = digit {digit|'_'} '.' {digit} [Exponent]</code></pre>
<pre><code>Exponent = ('E' | 'D' | 'F' ) ['+' | '-'] digit {digit}</code></pre>
<pre><code>hexDigit = digit | 'A' ... 'F'</code></pre>
<pre><code>digit    = '0' ... '9'</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14478">2.3.5.12</a></span>
Even though only the upper-case version is shown here, also the lower-case versions of the suffices and scale factor letters are supported.</div>
<div style="margin-left:63px"><span class="label"><a name="14179">2.3.5.13</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14180">2.3.5.13.1</a></span>
<pre><code>1234</code></pre>
<pre><code>0dh              0DH</code></pre>
<pre><code>12.3</code></pre>
<pre><code>4.567e8          4.567E8</code></pre>
<pre><code>0.57712566d-6    0.57712566D-6</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14181">2.3.6</a></span>
Characters</h4>
<div style="margin-left:63px"><span class="label"><a name="14182">2.3.6.1</a></span>
Character constants are denoted by the ordinal number of the character in hexadecimal notation followed by the letter <code>X</code> (or <code>x</code>).</div>
<div style="margin-left:63px"><span class="label"><a name="14183">2.3.6.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14184">2.3.6.2.1</a></span>
<pre><code>character = digit {hexDigit} ('X' | 'x')</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14185">2.3.6.3</a></span>
A character is encoded as a 8-bit code value using the ISO/IEC 8859-1 Latin-1 encoding scheme.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14186">2.3.7</a></span>
Strings</h4>
<div style="margin-left:63px"><span class="label"><a name="14187">2.3.7.1</a></span>
Strings are sequences of printable characters enclosed in single (') or double (&quot;) quote marks. The opening quote must be the same as the closing quote and must not occur within the string. A string must not extend over the end of a line. The number of characters in a string is called its length. </div>
<div style="margin-left:63px"><span class="label"><a name="16054">2.3.7.2</a></span>
A string of length 1 can be used wherever a character constant is allowed and vice versa.</div>
<div style="margin-left:63px"><span class="label"><a name="14188">2.3.7.3</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14189">2.3.7.3.1</a></span>
<pre><code>string = ''' {character} ''' | '&quot;' {character} '&quot;'</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14190">2.3.7.4</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14191">2.3.7.4.1</a></span>
<pre><code>'Oberon'</code></pre>
<pre><code>&quot;Don't worry!&quot;</code></pre>
<pre><code>'x'</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14198">2.3.8</a></span>
<b>Operators and Delimiters</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14199">2.3.8.1</a></span>
Operators and delimiters are the special characters, or character pairs listed below.</div>
<div style="margin-left:63px"><span class="label"><a name="14200">2.3.8.2</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
- </td>
<td>
<br>, </td>
<td>
<br>; </td>
<td>
<br>: </td>
<td>
<br>:= </td>
<td>
<br>. </td></tr>
<tr>
<td>
<br>.. </td>
<td>
<br>( </td>
<td>
<br>) </td>
<td>
<br>[ </td>
<td>
<br>] </td>
<td>
<br>{ </td></tr>
<tr>
<td>
<br>} </td>
<td>
<br>* </td>
<td>
<br>/ </td>
<td>
<br># </td>
<td>
<br>^ </td>
<td>
<br>+ </td></tr>
<tr>
<td>
<br>&lt;= </td>
<td>
<br>= </td>
<td>
<br>&gt;= </td>
<td>
<br>| </td>
<td>
<br>~ </td>
<td></td></tr></table></div>
<h4 style="margin-left:45px"><span class="label"><a name="14201">2.3.9</a></span>
Reserved Words</h4>
<div style="margin-left:63px"><span class="label"><a name="14202">2.3.9.1</a></span>
The reserved words consist of either all capital or all lower case letters and cannot be used as identifiers. All words listed below are reserved (only capital letter versions shown).</div>
<div style="margin-left:63px"><span class="label"><a name="17202">2.3.9.2</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
AND</td>
<td>
<br>ARRAY</td>
<td>
<br>BEGIN</td>
<td>
<br>BY</td>
<td>
<br>CASE</td></tr>
<tr>
<td>
<br>CONST</td>
<td>
<br>DIV</td>
<td>
<br>DO</td>
<td>
<br>ELSE</td>
<td>
<br>ELSIF</td></tr>
<tr>
<td>
<br>END</td>
<td>
<br>EXIT</td>
<td>
<br>EXTERN</td>
<td>
<br>FALSE</td>
<td>
<br>FOR</td></tr>
<tr>
<td>
<br>IF</td>
<td>
<br>IMPORT</td>
<td>
<br>IN</td>
<td>
<br>INLINE</td>
<td>
<br>INVAR</td></tr>
<tr>
<td>
<br>LOOP</td>
<td>
<br>MOD</td>
<td>
<br>MODULE</td>
<td>
<br>NIL</td>
<td>
<br>NOT</td></tr>
<tr>
<td>
<br>OF</td>
<td>
<br>OR</td>
<td>
<br>POINTER</td>
<td>
<br>PROC</td>
<td>
<br>PROCEDURE</td></tr>
<tr>
<td>
<br>RECORD</td>
<td>
<br>REPEAT</td>
<td>
<br>RETURN</td>
<td>
<br>THEN</td>
<td>
<br>TO</td></tr>
<tr>
<td>
<br>TRUE</td>
<td>
<br>TYPE</td>
<td>
<br>UNTIL</td>
<td>
<br>VAR</td>
<td>
<br>WHILE</td></tr></table></div>
<h4 style="margin-left:45px"><span class="label"><a name="14204">2.3.10</a></span>
Comments</h4>
<div style="margin-left:63px"><span class="label"><a name="14205">2.3.10.1</a></span>
Comments are arbitrary character sequences opened by the bracket <code>(*</code> and closed by <code>*)</code>. Comments may be nested. They do not affect the meaning of a program. Micron also supports line comments; text starting with <code>//</code> up to a line break is considered a comment.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14160">2.4</a></span>
Declarations and scope rules</h4>
<div style="margin-left:45px"><span class="label"><a name="14161">2.4.1</a></span>
Every identifier occurring in a program must be introduced by a declaration, unless it is a predeclared identifier. Declarations also specify certain permanent properties of an object, such as whether it is a constant, a type, a variable, or a procedure. The identifier is then used to refer to the associated object.</div>
<div style="margin-left:45px"><span class="label"><a name="14162">2.4.2</a></span>
The <i>scope</i> of an object <i>x</i> extends textually from the point of its declaration to the end of the block (module, procedure, or record) to which the declaration belongs and hence to which the object is <i>local</i>. It excludes the scopes of equally named objects which are declared in nested blocks. The scope rules are: </div>
<div style="margin-left:63px"><span class="label"><a name="14163">2.4.2.1</a></span>
No identifier may denote more than one object within a given scope (i.e. no identifier may be declared twice in a block); </div>
<div style="margin-left:63px"><span class="label"><a name="14164">2.4.2.2</a></span>
An object may only be referenced within its scope; </div>
<div style="margin-left:63px"><span class="label"><a name="14165">2.4.2.3</a></span>
A type<i>T</i> of the form POINTER TO <i>T1</i> (see <a href="#14278">2.6.7 Pointer types</a>) can be declared at a point where <i>T1</i> is still unknown. The declaration of <i>T1</i> must follow in the same type declaration section to which <i>T</i> belongs; </div>
<div style="margin-left:63px"><span class="label"><a name="14166">2.4.2.4</a></span>
Identifiers denoting record fields (see <a href="#14270">2.6.6 Record types</a>) are valid in record designators only. </div>
<div style="margin-left:45px"><span class="label"><a name="14167">2.4.3</a></span>
An identifier declared in a module block may be followed by an export mark (&quot; * &quot; or &quot; - &quot;) in its declaration to indicate that it is exported. An identifier <i>x</i> exported by a module <i>M</i> may be used in other modules, if they import <i>M</i> (see <a href="#14498">2.12 Modules</a>). The identifier is then denoted as <i>M.x</i> in these modules and is called a <i>qualified identifier</i>. Identifiers marked with &quot; - &quot; in their declaration are <i>read-only</i> in importing modules. </div>
<div style="margin-left:45px"><span class="label"><a name="14206">2.4.4</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14207">2.4.4.1</a></span>
<pre><code>qualident = [ident '.'] ident</code></pre>
<pre><code>identdef  = ident ['*' | '-']</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14208">2.4.5</a></span>
The following identifiers are predeclared; their meaning is defined in the indicated sections; either all capital or all lower case identifiers are supported (only capital versions shown).</div>
<div style="margin-left:45px"><span class="label"><a name="15953">2.4.6</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
ABS</td>
<td>
<br>ANY</td>
<td>
<br>ASSERT</td>
<td>
<br>BITAND</td>
<td>
<br>BITASR</td></tr>
<tr>
<td>
<br>BITNOT</td>
<td>
<br>BITOR</td>
<td>
<br>BITS</td>
<td>
<br>BITSHL</td>
<td>
<br>BITSHR</td></tr>
<tr>
<td>
<br>BITXOR</td>
<td>
<br>BOOLEAN</td>
<td>
<br>BYTE</td>
<td>
<br>CAP</td>
<td>
<br>CAST</td></tr>
<tr>
<td>
<br>CHAR</td>
<td>
<br>CHR</td>
<td>
<br>DEC</td>
<td>
<br>DEFAULT</td>
<td>
<br>DISPOSE</td></tr>
<tr>
<td>
<br>EXCL</td>
<td>
<br>FLT</td>
<td>
<br>FLT32</td>
<td>
<br>FLT64</td>
<td>
<br>FLOOR</td></tr>
<tr>
<td>
<br>HALT</td>
<td>
<br>INC</td>
<td>
<br>INCL</td>
<td>
<br>INT16</td>
<td>
<br>INT32</td></tr>
<tr>
<td>
<br>INT64</td>
<td>
<br>INT8</td>
<td>
<br>INTEGER</td>
<td>
<br>LEN</td>
<td>
<br>LONG</td></tr>
<tr>
<td>
<br>LONGINT</td>
<td>
<br>LONGREAL</td>
<td>
<br>MAX</td>
<td>
<br>MIN</td>
<td>
<br>NEW</td></tr>
<tr>
<td>
<br>ODD</td>
<td>
<br>ORD</td>
<td>
<br>PCALL</td>
<td>
<br>PRINT</td>
<td>
<br>PRINTLN</td></tr>
<tr>
<td>
<br>RAISE</td>
<td>
<br>REAL</td>
<td>
<br>SET</td>
<td>
<br>SHORT</td>
<td>
<br>SHORTINT</td></tr>
<tr>
<td>
<br>SIGNED</td>
<td>
<br>SIZE</td>
<td>
<br>STRLEN</td>
<td></td>
<td>
<br>UINT16</td></tr>
<tr>
<td>
<br>UINT32</td>
<td>
<br>UINT64</td>
<td>
<br>UINT8</td>
<td>
<br>UNSIGNED</td>
<td>
<br>VA_LIST</td></tr>
<tr>
<td>
<br>VARARG</td>
<td>
<br>VARARGS</td>
<td></td>
<td></td>
<td></td></tr></table></div>
<h4 style="margin-left:27px"><span class="label"><a name="14210">2.5</a></span>
Constant declarations</h4>
<div style="margin-left:45px"><span class="label"><a name="14211">2.5.1</a></span>
A constant declaration associates an identifier with a constant value.</div>
<div style="margin-left:45px"><span class="label"><a name="14212">2.5.2</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14213">2.5.2.1</a></span>
<pre><code>ConstDeclaration = identdef '=' ConstExpression</code></pre>
<pre><code>ConstExpression  = expression</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14214">2.5.3</a></span>
A constant expression is an expression that can be evaluated by a mere textual scan without actually executing the program. Its operands are constants (see <a href="#14306">2.8.2 Operands</a>) or predeclared functions (see <a href="#14136">6 Predeclared Procedure Reference</a>) that can be evaluated at compile time. Examples of constant declarations are:</div>
<div style="margin-left:45px"><span class="label"><a name="14215">2.5.4</a></span>
Examples:</div>
<div style="margin-left:63px"><span class="label"><a name="14216">2.5.4.1</a></span>
<pre><code>N = 100</code></pre>
<pre><code>limit = 2*N - 1</code></pre>
<pre><code>fullSet = {min(set) .. max(set)}</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14217">2.5.5</a></span><span class="ident">NOTE</span>
For compile time calculations of values the same rules as for runtime calculation apply. The ConstExpression of ConstDeclaration behaves as if each use of the constant identifier was replaced by the ConstExpression. An expression like <code>MAX(INT32)+1</code> thus causes an overflow of the INT32 range. To avoid this either <code>LONG(MAX(INT32))+1</code> or <code>MAX(INT32)+1I8</code> has to be used. </div>
<h4 style="margin-left:27px"><span class="label"><a name="14218">2.6</a></span>
Type declarations</h4>
<div style="margin-left:45px"><span class="label"><a name="14219">2.6.1</a></span>
A data type determines the set of values which variables of that type may assume, and the operators that are applicable. A type declaration associates an identifier with a type. In the case of structured types (arrays and records) it also defines the structure of variables of this type. A structured type cannot contain itself.</div>
<div style="margin-left:45px"><span class="label"><a name="14220">2.6.2</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14221">2.6.2.1</a></span>
<pre><code>TypeDeclaration = identdef '=' type</code></pre>
<pre><code>type            = NamedType | ArrayType | RecordType | PointerType | ProcedureType | enumeration</code></pre>
<pre><code>NamedType       = qualident</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14222">2.6.3</a></span>
Examples:</div>
<div style="margin-left:63px"><span class="label"><a name="14223">2.6.3.1</a></span>
<pre><code>Table = array N of real</code></pre>
<pre><code>Tree = pointer to Node</code></pre>
<pre><code>Node = record</code></pre>
<pre><code>  key: integer</code></pre>
<pre><code>  left, right: Tree</code></pre>
<pre><code>end</code></pre>
<pre><code>CenterTree = pointer to CenterNode</code></pre>
<pre><code>CenterNode = record (Node)</code></pre>
<pre><code>  width: integer</code></pre>
<pre><code>  subnode: Tree</code></pre>
<pre><code>end</code></pre>
<pre><code>Function = procedure(x: integer): integer</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14224">2.6.4</a></span>
Basic types</h4>
<div style="margin-left:63px"><span class="label"><a name="14225">2.6.4.1</a></span>
The basic types are denoted by predeclared identifiers. The associated operators are defined in <a href="#14322">2.8.3 Operators</a> and the predeclared function procedures in <a href="#14136">6 Predeclared Procedure Reference</a>. Either all capital or all lower case identifiers are supported (only capital versions shown). There are fixed and variable size basic types. For the fixed size basic types the byte widths and ranges are explicitly specified herein. The variable size basic types are just alternative names for the fixed size integer types.</div>
<div style="margin-left:63px"><span class="label"><a name="14226">2.6.4.2</a></span>
The values of the given fixed size basic types are the following:</div>
<div style="margin-left:63px"><span class="label"><a name="14251">2.6.4.3</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
BOOLEAN</td>
<td>
<br>1 byte</td>
<td>
<br>the truth values true and false</td></tr>
<tr>
<td>
<br>CHAR</td>
<td>
<br>1 byte</td>
<td>
<br>the characters of the Latin-1 set (0x .. 0ffx)</td></tr>
<tr>
<td>
<br>BYTE, UINT8</td>
<td>
<br>1 byte</td>
<td>
<br>the integers between 0 and 255</td></tr>
<tr>
<td>
<br>INT8</td>
<td>
<br>1 byte</td>
<td>
<br>the integers between -128 and 127</td></tr>
<tr>
<td>
<br>INT16</td>
<td>
<br>2 byte</td>
<td>
<br>the integers between -32'768 and 32'767</td></tr>
<tr>
<td>
<br>UINT16</td>
<td>
<br>2 byte</td>
<td>
<br>the integers between 0 and 65'535</td></tr>
<tr>
<td>
<br>INT32</td>
<td>
<br>4 byte</td>
<td>
<br>the integers between -2'147'483'648 and 2'147'483'647</td></tr>
<tr>
<td>
<br>UINT32</td>
<td>
<br>4 byte</td>
<td>
<br>the integers between 0 and 4'294'967'295</td></tr>
<tr>
<td>
<br>INT64</td>
<td>
<br>8 byte</td>
<td>
<br>the integers between -9'223'372'036'854'775'808 and 9'223'372'036'854'775'807</td></tr>
<tr>
<td>
<br>UINT64</td>
<td>
<br>8 byte</td>
<td>
<br>the integers between 0 and 18'446'744'073'709'551'615</td></tr>
<tr>
<td>
<br>REAL, FLT32</td>
<td>
<br>32 bit</td>
<td>
<br>an IEEE 754 floating point number</td></tr>
<tr>
<td>
<br>LONGREAL, FLT64</td>
<td>
<br>64 bit</td>
<td>
<br>an IEEE 754 floating point number</td></tr>
<tr>
<td>
<br>SET</td>
<td>
<br>4 byte</td>
<td>
<br>the sets of integers between 0 and MAX(SET)</td></tr></table></div>
<div style="margin-left:63px"><span class="label"><a name="14252">2.6.4.4</a></span>
The values of the given variable size basic types are the following:</div>
<div style="margin-left:63px"><span class="label"><a name="14253">2.6.4.5</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
SHORTINT </td>
<td>
<br>the integers between MIN(SHORTINT) and MAX(SHORTINT) </td></tr>
<tr>
<td>
<br>INTEGER </td>
<td>
<br>the integers between MIN(INTEGER) and MAX(INTEGER) </td></tr>
<tr>
<td>
<br>LONGINT </td>
<td>
<br>the integers between MIN(LONGINT) and MAX(LONGINT)</td></tr></table></div>
<div style="margin-left:63px"><span class="label"><a name="14254">2.6.4.6</a></span>
INT64, INT32, INT16, INT8, LONGINT, INTEGER, SHORTINT are signed integer types, UIN64, UINT32, UINT16, UINT8, and BYTE are unsigned integer types, REAL and LONGREAL are <a href="#14539">Floating-point types</a>, and together they are called numeric types. The larger type includes (the values of) the smaller type according to the following relations:</div>
<div style="margin-left:63px"><span class="label"><a name="14255">2.6.4.7</a></span>
<pre><code>INT64 &gt;= INT32 &gt;= INT16 &gt;= INT8</code></pre>
<pre><code>UINT64 &gt;= UINT32 &gt;= UINT16 &gt;= UINT8</code></pre>
<pre><code>LONGREAL &gt;= REAL</code></pre>
<pre><code>LONGINT &gt;= INTEGER &gt;= SHORTINT</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14256">2.6.4.8</a></span><span class="ident">NOTE</span>
Oberon and Oberon+ both support implicit type casts from integer to floating point and vice versa. Micron requres an explicit cast. To convert an integer to a floating point type, the FLT() built-in function should be used. To convert a numeric type to a signed integer, the SIGNED() function should be used. To convert a numeric byp to an unsigned integer, the UNSIGNED() function should be used.</div>
<div style="margin-left:63px"><span class="label"><a name="14258">2.6.4.9</a></span>
A compiler may map the variable size integer names to any of the fixed size signed integers as long as the inclusion relations are obeyed. By default a correspondence of LONGINT with INT64, INTEGER with INT32 and SHORTINT with INT16 is assumed.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14257">2.6.5</a></span>
<a href=""><b>A</b></a><b>rray types</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14260">2.6.5.1</a></span>
An array is a structure consisting of a number of elements which are all of the same type, called the element type. The number of elements of an array is called its length. The length is a positive integer. The elements of the array are designated by indices, which are integers between 0 and the length minus 1. </div>
<div style="margin-left:63px"><span class="label"><a name="14261">2.6.5.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14262">2.6.5.2.1</a></span>
<pre><code>ArrayType  = ARRAY [ length ] OF type | '[' [ length ] ']' type</code></pre>
<pre><code>length     = ConstExpression | VAR varlength</code></pre>
<pre><code>varlength  = expression</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14263">2.6.5.3</a></span>
Arrays declared without length are called <i>open arrays</i>. They are restricted to pointer base types (see <a href="#14278">2.6.7 Pointer types</a>).</div>
<div style="margin-left:63px"><span class="label"><a name="16001">2.6.5.4</a></span><span class="ident">NOTE</span>
In contrast to Oberon and Oberon+, in Micron only the first dimension of a multi-dimensional array can be an open array.</div>
<div style="margin-left:63px"><span class="label"><a name="15994">2.6.5.5</a></span>
Arrays of arrays are stored in row-major order.</div>
<div style="margin-left:63px"><span class="label"><a name="14264">2.6.5.6</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14265">2.6.5.6.1</a></span>
<pre><code>array 10 of integer</code></pre>
<pre><code>pointer to array of char</code></pre>
<pre><code>[N] T</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14266">2.6.5.7</a></span>
Local variables of array type can have variable lengths calculated at runtime; in this case the LengthList is prefixed with the VAR reserved word; the expression cannot reference other local variables of the same scope.</div>
<div style="margin-left:63px"><span class="label"><a name="14267">2.6.5.8</a></span><span class="ident">NOTE</span>
In contrast to array pointers allocated with NEW(), variable length arrays (VLA) can be allocated on the stack instead of the heap (depending on the compiler and supported options), which makes them attractive to low-resource embedded applications where dynamic memory allocation is not feasible. It is also interesting to note that already the length/range of ALGOL 60 arrays was defined using an ordinary arithmetic expression and thus could be calculated at runtime; even ALGOL W had this feature, but unfortunately it was removed in Pascal, and even Oberon-07 still uses a const expression for array lengths evaluated at compile time. </div>
<div style="margin-left:63px"><span class="label"><a name="14268">2.6.5.9</a></span>
Array lengths of at least MAX(UINT32) shall be accepted by a compiler, for constant, dynamic and variable lengths.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14270">2.6.6</a></span>
Record types</h4>
<div style="margin-left:63px"><span class="label"><a name="14271">2.6.6.1</a></span>
A record type is a structure consisting of a fixed number of elements, called fields, with possibly different types. The record type declaration specifies the name and type of each field. The scope of the field identifiers extends from the point of their declaration to the end of the record type, but they are also visible within designators referring to elements of record variables (see <a href="#14306">2.8.2 Operands</a>). If a record type is exported, field identifiers that are to be visible outside the declaring module must be marked. They are called public fields; unmarked elements are called private fields.</div>
<div style="margin-left:63px"><span class="label"><a name="14273">2.6.6.2</a></span>
The syntax for a record type also makes provisions for an optional variant part, started by the CASE reserved word. The variant part implies that a record type may be specified as consisting of several variants. This means that different variables, although said to be of the same type, may assume structures which differ in a certain manner. The differences may consist of a different number and different types of components. Each variant is characterised by a field of record type, according to which the variants are discriminated.</div>
<div style="margin-left:63px"><span class="label"><a name="14274">2.6.6.3</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14275">2.6.6.3.1</a></span>
<pre><code>RecordType = RECORD [FixedPart][VariantPart] END</code></pre>
<pre><code>FixedPart = FieldList { [';'] FieldList}</code></pre>
<pre><code>FieldList  = [ IdentList ':' type ] | INLINE identdef ':' type</code></pre>
<pre><code>VariantPart   = CASE { ['|'] [INLINE] identdef ':' type }</code></pre>
<pre><code>IdentList  = identdef { [','] identdef }</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14277">2.6.6.4</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14276">2.6.6.4.1</a></span>
<pre><code>record</code></pre>
<pre><code>  day, month, year: integer</code></pre>
<pre><code>end</code></pre>
<pre><code>RECORD</code></pre>
<pre><code>  name, firstname: ARRAY 32 of CHAR</code></pre>
<pre><code>  age: INTEGER</code></pre>
<pre><code>  salary: REAL</code></pre>
<pre><code>END</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14279">2.6.6.5</a></span>
Fields of record type of the fixed part or the fields of the variant part can be prefixed by the INLINE (or abbreviated only IN) reserved word, in which case the name of the field or variant becomes transparent, and the fields of the corresponding record type are directly embedded in the enclosing record. </div>
<div style="margin-left:63px"><span class="label"><a name="14280">2.6.6.6</a></span>
Each field or variant of a record must have a name which is unique within the record; if a field of a record embedded with the INLINE prefix has the same name as a field or variant of the embedding record, then the name of the prefixed field or variant must be used to access it.</div>
<div style="margin-left:63px"><span class="label"><a name="15730">2.6.6.7</a></span>
TODO: open array as last field (no variant part) with new(ptr,len)</div>
<h4 style="margin-left:45px"><span class="label"><a name="14278">2.6.7</a></span>
<a href=""><b>P</b></a><b>ointer types</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14281">2.6.7.1</a></span>
Variables of a pointer type P assume as values pointers to variables of some type T. T is called the pointer base type of P and can be of any type. </div>
<div style="margin-left:63px"><span class="label"><a name="14282">2.6.7.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14283">2.6.7.2.1</a></span>
<pre><code>PointerType = ( POINTER TO | '^' ) type</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14284">2.6.7.3</a></span>
If p is a variable of type <code>P = POINTER TO T</code>, a call of the predeclared procedure <code>NEW(p)</code> (see <a href="#14136">6 Predeclared Procedure Reference</a>) allocates a variable of type T in free storage. If T is a record type or an array type with fixed length, the allocation has to be done with <code>NEW(p)</code>; if T is an open array type, the allocation has to be done with <code>NEW(p, e)</code> where T is allocated with the length given by the expression e. In either case a pointer to the allocated variable is assigned to <code>p</code>. <code>p</code> is of type P. The referenced variable <code>p^</code> is of type T. Any pointer variable may assume the value NIL, which points to no variable at all. If an allocated record or array is no longer used, it has to be explicitly deallocated with <code>DISPOSE(p)</code>.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14285">2.6.8</a></span>
Procedure types</h4>
<div style="margin-left:63px"><span class="label"><a name="14286">2.6.8.1</a></span>
Variables of a procedure type T have a procedure (or NIL) as value. If a procedure P is assigned to a variable of type T, the formal parameter lists and result types (see <a href="#14458">2.11.12 Formal parameters</a>) of P and T must <i>match</i> (see <a href="#14532">3 Definition of terms</a>). A procedure P assigned to a variable or a formal parameter must not be a predeclared, nor an inlined procedure.</div>
<div style="margin-left:63px"><span class="label"><a name="14288">2.6.8.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14289">2.6.8.2.1</a></span>
<pre><code>ProcedureType = PROCEDURE [FormalParameters]</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14287">2.6.8.3</a></span><span class="ident">NOTE</span>
Traditional Oberon versions don’t support assignment of procedures local to another procedure to a procedure type variable. Oberon+ as well as Micron don’t make this restriction.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14291">2.6.9</a></span>
<b>Enumeration types</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14292">2.6.9.1</a></span>
An enumeration is a list of identifiers that denote the elements which constitute the type. They, and no other values, belong to this type. These identifiers are constants. </div>
<div style="margin-left:63px"><span class="label"><a name="14669">2.6.9.2</a></span>
The export mark of the enumeration type declaration also applies to the elements of the enumeration.</div>
<div style="margin-left:63px"><span class="label"><a name="14293">2.6.9.3</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14294">2.6.9.3.1</a></span>
<pre><code>enumeration ::= '(' constEnum ')' <br />constEnum ::= ident [ '=' ConstExpression ] { [','] ident } </code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14667">2.6.9.4</a></span>
The values of an enumeration are ordered, and the ordering relation is defined by their sequence in the enumeration. If T is an enumeration type then <code>MIN(T)</code> returns the first and <code>MAX(T)</code> the last element of the enumeration. </div>
<div style="margin-left:63px"><span class="label"><a name="14297">2.6.9.5</a></span>
The ordinal number of a constant enumeration element can be obtained using the <code>ORD</code> predeclared procedure. <code>CAST</code> is the reverse operation. The ordinal number of the first element is determined by the optional constant expression, or 0 by default. <code>INC</code> returns the next and <code>DEC</code> the previous element. <code>INC(MAX(T))</code> and <code>DEC(MIN(T))</code> are undefined and terminate the program.</div>
<div style="margin-left:63px"><span class="label"><a name="14295">2.6.9.6</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14296">2.6.9.6.1</a></span>
<pre><code>(red, green, blue)</code></pre>
<pre><code>(Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday)</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="15364">2.6.10</a></span>
Alias types</h4>
<div style="margin-left:63px"><span class="label"><a name="15365">2.6.10.1</a></span>
A type can be an alias of another type. The other type is referenced with a qualident. If the other type is in another module, it must be exported. A type is considered the same type as its alias.</div>
<div style="margin-left:63px"><span class="label"><a name="15366">2.6.10.2</a></span><span class="ident">NOTE</span>
If the other type is an enumeration type in another module M, the elements e of this enumeration type still have to be denoted by M.e.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14298">2.7</a></span>
<a href=""><b>V</b></a><b>ariable declarations</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14299">2.7.1</a></span>
Variable declarations introduce variables by defining an identifier and a data type for them. The initial value of a variable is undefined.</div>
<div style="margin-left:45px"><span class="label"><a name="14300">2.7.2</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14301">2.7.2.1</a></span>
<pre><code>VariableDeclaration = IdentList ':' type</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14302">2.7.3</a></span>
Examples:</div>
<div style="margin-left:63px"><span class="label"><a name="14303">2.7.3.1</a></span>
<pre><code>i, j, k: integer</code></pre>
<pre><code>x, y: real</code></pre>
<pre><code>p, q: bool</code></pre>
<pre><code>s: set</code></pre>
<pre><code>F: Function</code></pre>
<pre><code>a: array 100 of real</code></pre>
<pre><code>w: array 16 of record</code></pre>
<pre><code>     name: arra 32 of char</code></pre>
<pre><code>     count: integer</code></pre>
<pre><code>   end</code></pre>
<pre><code>t, c: Tree</code></pre></div>
<h4 style="margin-left:27px"><span class="label"><a name="14304">2.8</a></span>
<a href=""><b>E</b></a><b>xpressions</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14305">2.8.1</a></span>
Expressions are constructs denoting rules of computation whereby constants and current values of variables are combined to compute other values by the application of operators and function procedures. Expressions consist of operands and operators. Parentheses may be used to express specific associations of operators and operands.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14306">2.8.2</a></span>
<a href=""><b>O</b></a><b>perands</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14307">2.8.2.1</a></span>
With the exception of constructors and literal constants (numbers, character constants, or strings), operands are denoted by designators. A designator consists of an identifier referring to a constant, variable, or procedure. This identifier may possibly be qualified by a module identifier (see <a href="#14160">2.4 Declarations and scope rules</a> and <a href="#14498">2.12 Modules</a>) and may be followed by selectors if the designated object is an element of a structure. </div>
<div style="margin-left:63px"><span class="label"><a name="14308">2.8.2.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14309">2.8.2.2.1</a></span>
<pre><code>designator = qualident {selector}</code></pre>
<pre><code>selector   = '.' ident | '[' expression ']' | '^' | '(' qualident ')'</code></pre>
<pre><code>ExpList    = expression {[','] expression}</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14310">2.8.2.3</a></span>
If <code>a</code> designates an array, then <code>a[e]</code> denotes that element of <code>a</code> whose index is the current value of the expression <code>e</code>. The type of <code>e</code> must be an <i>integer type</i>. </div>
<div style="margin-left:63px"><span class="label"><a name="14311">2.8.2.4</a></span>
If <code>r</code> designates a record, then <code>r.f</code> denotes the field <code>f</code> of <code>r</code>. If <code>p</code> designates a pointer, <code>p^</code> denotes the variable which is referenced by <code>p</code>. The designators <code>p^.f</code> and <code>p^[e]</code> may be abbreviated as <code>p.f</code> and <code>p[e]</code>, i.e. record and array selectors imply dereferencing.</div>
<div style="margin-left:63px"><span class="label"><a name="14312">2.8.2.5</a></span>
Dereferencing is also implied if a pointer is assigned to a variable of a record or array type, if a pointer is used as actual parameter for a formal parameter of a record or array type, or if a pointer is used as argument of the predeclared procedure LEN().</div>
<div style="margin-left:63px"><span class="label"><a name="14313">2.8.2.6</a></span>
If <code>a</code> or <code>r</code> are read-only, then also <code>a[e]</code> and <code>r.f</code> are read-only.</div>
<div style="margin-left:63px"><span class="label"><a name="14314">2.8.2.7</a></span>
A type cast <code>v(T)</code> converts the original type of <code>v</code> to T. Within the designator, <code>v</code> is then regarded as having the type T instead of the original type. The cast is applicable, if <code>v</code> is a pointer type.</div>
<div style="margin-left:63px"><span class="label"><a name="14315">2.8.2.8</a></span>
If the designated object is a constant or a variable, then the designator refers to its current value. If it is a procedure, the designator refers to that procedure unless it is followed by a (possibly empty) parameter list in which case it implies an activation of that procedure and stands for the value resulting from its execution. The actual parameters must correspond to the formal parameters as in proper procedure calls (see <a href="#14458">2.11.12 Formal parameters</a>).</div>
<div style="margin-left:63px"><span class="label"><a name="14319">2.8.2.9</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14320">2.8.2.9.1</a></span>
<pre><code>i                        </code></pre>
<pre><code>a[i]                     </code></pre>
<pre><code>w[3].name[i]             </code></pre>
<pre><code>t.left.right             </code></pre>
<pre><code>t(CenterTree).subnode </code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14322">2.8.3</a></span>
<a href=""><b>O</b></a><b>perators</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14323">2.8.3.1</a></span>
Different classes of operators with different precedences (binding strengths) are syntactically distinguished in expressions. The operator <code>~</code> has the highest precedence, followed by multiplication operators, addition operators, and relations. Operators of the same precedence associate from left to right. For example, <code>x-y-z</code> stands for <code>(x-y)-z</code>.</div>
<div style="margin-left:63px"><span class="label"><a name="14324">2.8.3.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14321">2.8.3.2.1</a></span>
<pre><code>expression       = SimpleExpression [ relation SimpleExpression ]</code></pre>
<pre><code>relation         = '=' | '#' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | IN</code></pre>
<pre><code>SimpleExpression = ['+' | '-'] term { AddOperator term }</code></pre>
<pre><code>AddOperator      = '+' | '-' | OR</code></pre>
<pre><code>term             = factor {MulOperator factor}</code></pre>
<pre><code>MulOperator      = '*' | '/' | DIV | MOD | '&amp;' | AND</code></pre>
<pre><code>literal          = number | string | hexstring | hexchar</code></pre>
<pre><code>                   | NIL | TRUE | FALSE | set</code></pre>
<pre><code>constructor      = NamedType '{' [ component {',' component} ] '}'</code></pre>
<pre><code>component        = ConstExpression</code></pre>
<pre><code>factor           = literal | designator [ActualParameters]</code></pre>
<pre><code>	       | '(' expression ')' | ('~'|NOT) factor</code></pre>
<pre><code>	       | '@' designator | constructor</code></pre>
<pre><code>ActualParameters = '(' [ ExpList ] ')'</code></pre>
<pre><code>set              = '{' [ element {[','] element} ] '}'</code></pre>
<pre><code>element          = expression ['..' expression]</code></pre></div>
<h4 style="margin-left:63px"><span class="label"><a name="14325">2.8.3.3</a></span>
Logical operators</h4>
<div style="margin-left:81px"><span class="label"><a name="14326">2.8.3.3.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
OR </td>
<td>
<br>logical disjunction </td>
<td>
<br><code>p or q</code> </td>
<td>
<br><i>if p then TRUE, else q</i> </td></tr>
<tr>
<td>
<br>&amp;, AND </td>
<td>
<br>logical conjunction </td>
<td>
<br><code>p &amp; q</code> </td>
<td>
<br><i>if p then q, else FALSE</i> </td></tr>
<tr>
<td>
<br>~, NOT</td>
<td>
<br>negation </td>
<td>
<br><code>~p</code> </td>
<td>
<br><i>not p</i></td></tr></table></div>
<div style="margin-left:81px"><span class="label"><a name="14327">2.8.3.3.2</a></span>
These operators apply to BOOLEAN operands and yield a BOOLEAN result.</div>
<div style="margin-left:81px"><span class="label"><a name="15631">2.8.3.3.3</a></span><span class="ident">NOTE</span>
In addition to &amp; and ~, Micron supports the AND and NOT operators with the same meaning, for compatibility with Pascal and Modula-2.</div>
<h4 style="margin-left:63px"><span class="label"><a name="14328">2.8.3.4</a></span>
<a href=""><b>A</b></a><b>rithmetic operators</b></h4>
<div style="margin-left:81px"><span class="label"><a name="14329">2.8.3.4.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
+ </td>
<td>
<br>sum </td></tr>
<tr>
<td>
<br>- </td>
<td>
<br>difference </td></tr>
<tr>
<td>
<br>* </td>
<td>
<br>product </td></tr>
<tr>
<td>
<br>/ </td>
<td>
<br>real quotient </td></tr>
<tr>
<td>
<br>DIV </td>
<td>
<br>integer quotient </td></tr>
<tr>
<td>
<br>MOD </td>
<td>
<br>modulus</td></tr></table></div>
<div style="margin-left:81px"><span class="label"><a name="14330">2.8.3.4.2</a></span>
The operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> apply to operands of numeric types.</div>
<div style="margin-left:81px"><span class="label"><a name="14479">2.8.3.4.3</a></span>
When used as a binary operator, both operands must be of either of signed integer, unsigned integer or floating point type.</div>
<div style="margin-left:81px"><span class="label"><a name="14480">2.8.3.4.4</a></span><span class="ident">NOTE</span>
This is the same rule as in Modula-2, <i>where both operands must be either of type CARDINAL [...], in which case the result is of the type CARDINAL, or they must both be of type INTEGER [...], in which case the result is of type INTEGER</i>. The Ada language has a similar rule. The rules of the C language in contrast are much more complicated (see e.g. <a href="https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules"><u>here</u></a>), but it is always possible to add explicit conversions when migrating C to Micron. </div>
<div style="margin-left:81px"><span class="label"><a name="15974">2.8.3.4.5</a></span>
As an exception, if one of the operands is an unsigned integer constant and the other operand is of type integer, the unsigned integer constant is converted to the smallest integer type which includes the constant value.</div>
<div style="margin-left:81px"><span class="label"><a name="14475">2.8.3.4.6</a></span>
The type of the result is the type of that operand which includes the type of the other operand (see <a href="#14255">2.6.4.7</a>).</div>
<div style="margin-left:81px"><span class="label"><a name="15820">2.8.3.4.7</a></span>
The operator '<code>/</code>' applies to real operands only.</div>
<div style="margin-left:81px"><span class="label"><a name="14473">2.8.3.4.8</a></span>
The operators <code>DIV</code> and <code>MOD</code> apply to integer operands only. They are related by the following formulas defined for any <code>x</code> and positive divisors <code>y</code>:</div>
<div style="margin-left:99px"><span class="label"><a name="14331">2.8.3.4.8.1</a></span>
<pre><code>x = (x DIV y) * y + (x MOD y)</code></pre>
<pre><code>0 &lt;= (x MOD y) &lt; y</code></pre></div>
<div style="margin-left:81px"><span class="label"><a name="14474">2.8.3.4.9</a></span>
When used as monadic (unary) operators, '-' denotes sign inversion and '+' denotes the identity operation. If the unary '-' or '+' is applied to an operand of unsigned integer type, the result is the next larger signed integer type, or an error if the operand is of type UIN64. Otherwise the type of the result is the same as the type of the operand.</div>
<div style="margin-left:81px"><span class="label"><a name="14332">2.8.3.4.10</a></span>
Examples:</div>
<div style="margin-left:99px"><span class="label"><a name="14333">2.8.3.4.10.1</a></span>
<pre><code>x    y    x DIV y    x MOD y</code></pre>
<pre><code>5    3    1          2</code></pre>
<pre><code>-5   3    -2         1</code></pre></div>
<div style="margin-left:81px"><span class="label"><a name="14334">2.8.3.4.11</a></span><span class="ident">NOTE</span>
Micron doesn’t do overflow checks. If the representation of the result of an arithmetic operation would require a wider integer type than provided by the type of the expression, the behaviour is undefined; e.g. <code>MAX(INT32)+1</code> causes an overflow, i.e. the result could be MIN(INT32) or anything else. </div>
<h4 style="margin-left:63px"><span class="label"><a name="14335">2.8.3.5</a></span>
Set Operators</h4>
<div style="margin-left:81px"><span class="label"><a name="14336">2.8.3.5.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
+ </td>
<td>
<br>union </td></tr>
<tr>
<td>
<br>- </td>
<td>
<br>difference (x - y = x * (-y)) </td></tr>
<tr>
<td>
<br>* </td>
<td>
<br>intersection </td></tr>
<tr>
<td>
<br>/ </td>
<td>
<br>symmetric set difference (x / y = (x-y) + (y-x))</td></tr></table></div>
<div style="margin-left:81px"><span class="label"><a name="14337">2.8.3.5.2</a></span>
Set operators apply to operands of type SET and yield a result of type SET. The monadic minus sign denotes the complement of <code>x</code>, i.e. <code>-x</code> denotes the set of integers between 0 and <code>MAX(SET)</code> which are not elements of <code>x</code>. Set operators are not associative (<code>(a+b)-c # a+(b-c)</code>).</div>
<div style="margin-left:81px"><span class="label"><a name="14338">2.8.3.5.3</a></span>
A set constructor defines the value of a set by listing its elements between curly brackets. The elements must be integers in the range <code>0..MAX(SET)</code>. A range <code>a..b</code> denotes all integers in the interval [a, b].</div>
<h4 style="margin-left:63px"><span class="label"><a name="14339">2.8.3.6</a></span>
Relations</h4>
<div style="margin-left:81px"><span class="label"><a name="14340">2.8.3.6.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
= </td>
<td>
<br>equal </td></tr>
<tr>
<td>
<br># </td>
<td>
<br>unequal </td></tr>
<tr>
<td>
<br>&lt; </td>
<td>
<br>less </td></tr>
<tr>
<td>
<br>&lt;= </td>
<td>
<br>less or equal </td></tr>
<tr>
<td>
<br>&gt; </td>
<td>
<br>greater </td></tr>
<tr>
<td>
<br>&gt;= </td>
<td>
<br>greater or equal </td></tr>
<tr>
<td>
<br>IN </td>
<td>
<br>membership</td></tr></table></div>
<div style="margin-left:81px"><span class="label"><a name="14341">2.8.3.6.2</a></span>
Relations yield a BOOLEAN result. </div>
<div style="margin-left:81px"><span class="label"><a name="15805">2.8.3.6.3</a></span>
The relations <code>=</code>, <code>#</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> apply to the numeric types, as well as constant enumerations, pointer types, CHAR, string literals, and CHAR arrays containing <code>0x</code> as a terminator. </div>
<div style="margin-left:81px"><span class="label"><a name="14675">2.8.3.6.4</a></span>
The relations <code>=</code> and <code>#</code> also apply to BOOLEAN, and SET, as well procedure types. </div>
<div style="margin-left:81px"><span class="label"><a name="15808">2.8.3.6.5</a></span>
The IN relation applies to SET.</div>
<div style="margin-left:81px"><span class="label"><a name="15804">2.8.3.6.6</a></span>
In general, both operands must be of the same type. If the operand are of numeric type, both must be either of signed integer, unsigned integer or floating point type. </div>
<div style="margin-left:81px"><span class="label"><a name="15975">2.8.3.6.7</a></span>
If one of the operands is an unsigned integer constant and the other operand is of type integer, the unsigned integer constant is converted to the smallest integer type which includes the constant value. </div>
<div style="margin-left:81px"><span class="label"><a name="15976">2.8.3.6.8</a></span>
String literals, CHAR and CHAR array operands can be mixed. </div>
<div style="margin-left:81px"><span class="label"><a name="15977">2.8.3.6.9</a></span>
If both operands are pointers, the specific type doesn't matter; the same applies to procedure types. </div>
<div style="margin-left:81px"><span class="label"><a name="14674">2.8.3.6.10</a></span>
<code>x IN s</code> stands for <i>x is an element of s</i>. If <code>s</code> is of type SET, <code>x</code> must be of an integer type. </div>
<div style="margin-left:81px"><span class="label"><a name="14342">2.8.3.6.11</a></span>
Examples:</div>
<div style="margin-left:99px"><span class="label"><a name="14343">2.8.3.6.11.1</a></span>
<pre><code>1991                   // integer</code></pre>
<pre><code>i div 3                // integer</code></pre>
<pre><code>~p or q                // boolean</code></pre>
<pre><code>(i+j) * (i-j)          // integer</code></pre>
<pre><code>s - {8, 9, 13}         // set</code></pre>
<pre><code>i + x                  // real</code></pre>
<pre><code>a[i+j] * a[i-j]        // real</code></pre>
<pre><code>(0&lt;=i) &amp; (i&lt;100)       // boolean</code></pre>
<pre><code>t.key = 0              // boolean</code></pre>
<pre><code>k in {i..j-1}          // boolean</code></pre>
<pre><code>w[i].name &lt;= &quot;John&quot;    // boolean</code></pre>
<pre><code>t is CenterTree        // boolean</code></pre></div>
<h4 style="margin-left:63px"><span class="label"><a name="14344">2.8.3.7</a></span>
String operators</h4>
<div style="margin-left:81px"><span class="label"><a name="14345">2.8.3.7.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 >
<tr>
<td>
+ </td>
<td>
<br>concatenation</td></tr></table></div>
<div style="margin-left:81px"><span class="label"><a name="14346">2.8.3.7.2</a></span>
The concatenation operator applies to string and character literals. The resulting string consists of the characters of the first operand followed by the characters of the second operand. </div>
<h4 style="margin-left:63px"><span class="label"><a name="14662">2.8.3.8</a></span>
Address operator</h4>
<div style="margin-left:81px"><span class="label"><a name="14663">2.8.3.8.1</a></span>
The address operator '@' can be applied to a variable, parameter, record field or array element, which is visible and not read-only; the operator yields the address of the object.</div>
<div style="margin-left:81px"><span class="label"><a name="14664">2.8.3.8.2</a></span>
If <code>v</code> designates a variable or parameter of type T, then <code>@v</code> denotes the address of <code>v</code> with the type <code>POINTER TO T.</code></div>
<div style="margin-left:81px"><span class="label"><a name="14665">2.8.3.8.3</a></span>
If <code>r.f</code> designates a record field <code>f</code> of type T, then <code>@r.f</code> denotes the address of field <code>f</code> with the type <code>POINTER TO T</code>.</div>
<div style="margin-left:81px"><span class="label"><a name="14666">2.8.3.8.4</a></span>
If <code>a[e]</code> designates an array element of type T at index <code>e</code>, then <code>@a[e]</code> denotes the address of the element at index <code>e</code>; the address is of type <code>POINTER TO T</code>.</div>
<h4 style="margin-left:63px"><span class="label"><a name="14349">2.8.3.9</a></span>
Function Call</h4>
<div style="margin-left:81px"><span class="label"><a name="14350">2.8.3.9.1</a></span>
A function call is a factor in an expression. In contrast to <a href="#14374">2.9.6 Procedure calls</a> in a function call the actual parameter list is mandatory. Each expression in the actual parameters list (if any) is used to initialize a corresponding formal parameter. The number of expressions in the actual parameter list must correspond the number of formal parameters. See also <a href="#14458">2.11.12 Formal parameters</a>.</div>
<div style="margin-left:81px"><span class="label"><a name="14351">2.8.3.9.2</a></span>
Syntax:</div>
<div style="margin-left:99px"><span class="label"><a name="14352">2.8.3.9.2.1</a></span>
<pre><code>FunctionCall           = designator ActualParameters</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14347">2.8.4</a></span>
Constructors</h4>
<div style="margin-left:63px"><span class="label"><a name="14348">2.8.4.1</a></span>
With constructors, record, array and pointer literals can be declared. </div>
<div style="margin-left:63px"><span class="label"><a name="14354">2.8.4.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="17796">2.8.4.2.1</a></span>
<code>constructor = [NamedType] '{' [ component {[','] component} ] '}' </code>
<br><code>component = ident ':' expression </code>
<br><code>	| '[' ConstExpression ']' ':' expression </code>
<br><code>	| expression ['..' expression] </code></div>
<div style="margin-left:63px"><span class="label"><a name="15629">2.8.4.3</a></span>
A constructor consists of an optional  NamedType and a list of either named, indexed or anonymous components. Named, Indexed and anonymous components can be mixed in the list.</div>
<div style="margin-left:63px"><span class="label"><a name="17798">2.8.4.4</a></span>
When the type of a constructor can be inferred (e.g. by the left side of an assignment), the NamedType prefix can be left out.</div>
<div style="margin-left:63px"><span class="label"><a name="14633">2.8.4.5</a></span>
If NamedType is a record type, then anonymous or named components can be used to assign field values; anonymous components are associated with fields in the order of declaration. If the record type has a variant part, only named component can be used, and only one option of the variant part can be initialized in the constructor.</div>
<div style="margin-left:63px"><span class="label"><a name="14634">2.8.4.6</a></span>
If NamedType is an array type, then anonymous or indexed components can be used to assign element values; anonymous components are associated with elements in the order of indizes. The array type may be an open array in which case the number of elements is determined by the number of components or the largest index component.</div>
<div style="margin-left:63px"><span class="label"><a name="14635">2.8.4.7</a></span>
If NamedType is a pointer type, then there is exactly one anonymous component which is an unsigned integer type constant representing the address. </div>
<div style="margin-left:63px"><span class="label"><a name="14636">2.8.4.8</a></span>
For each field or element which is of record, array or pointer type, an embedded constructor is required. </div>
<div style="margin-left:63px"><span class="label"><a name="14637">2.8.4.9</a></span>
Example:</div>
<div style="margin-left:81px"><span class="label"><a name="14638">2.8.4.9.1</a></span>
<code>myVal := Rect{0,0,x1,y1};</code></div>
<h4 style="margin-left:63px"><span class="label"><a name="16058">2.8.4.10</a></span>
Hex Strings</h4>
<div style="margin-left:81px"><span class="label"><a name="16059">2.8.4.10.1</a></span>
Hex strings are sequences of bytes encoded in hexadecimal format and enclosed in dollar signs. The number of hex digits in the string must be even, two hex digits per byte. The number of bytes encoded in a hex string is called its length. Line breaks and other white space between the dollar signs is ignored. Both upper and lower-case hex digits are supported. </div>
<div style="margin-left:81px"><span class="label"><a name="16061">2.8.4.10.2</a></span>
Syntax:</div>
<div style="margin-left:99px"><span class="label"><a name="16062">2.8.4.10.2.1</a></span>
<pre><code>hexstring = '$' {hexDigit} '$'</code></pre></div>
<div style="margin-left:81px"><span class="label"><a name="16063">2.8.4.10.3</a></span>
Examples:</div>
<div style="margin-left:99px"><span class="label"><a name="16064">2.8.4.10.3.1</a></span>
<pre><code>const arrow = $0F0F 0060 0070 0038 001C 000E 0007 8003 C101 E300 <br />               7700 3F00 1F00 3F00 7F00 FF00$</code></pre></div>
<div style="margin-left:81px"><span class="label"><a name="16066">2.8.4.10.4</a></span><span class="ident">NOTE</span>
Hex strings are provided for compatibility with Oberon+; they are essentially an alternative syntax for an open byte array constructor.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14355">2.9</a></span>
<a href=""><b>S</b></a><b>tatements</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14356">2.9.1</a></span>
Statements denote actions. There are elementary and structured statements. Elementary statements are not composed of any parts that are themselves statements. They are the assignment, the procedure call, the return, and the <code>exit</code> statement. Structured statements are composed of parts that are themselves statements. They are used to express sequencing and conditional, selective, and repetitive execution.</div>
<div style="margin-left:45px"><span class="label"><a name="14357">2.9.2</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14358">2.9.2.1</a></span>
<pre><code>statement = [ assignment | ProcedureCall | IfStatement</code></pre>
<pre><code>            | CaseStatement  | WithStatement | LoopStatement</code></pre>
<pre><code>            | ExitStatement | GotoStatement | gotoLabel </code></pre>
<pre><code>	| ReturnStatement | RepeatStatement | ForStatement ]</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14359">2.9.3</a></span>
Statement sequences</h4>
<div style="margin-left:63px"><span class="label"><a name="14360">2.9.3.1</a></span>
Statement sequences denote the sequence of actions specified by the component statements which are optionally separated by semicolons.</div>
<div style="margin-left:63px"><span class="label"><a name="14361">2.9.3.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14362">2.9.3.2.1</a></span>
<pre><code>StatementSequence = statement { [&quot;;&quot;] statement} </code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14447">2.9.4</a></span>
Statement block</h4>
<div style="margin-left:63px"><span class="label"><a name="14448">2.9.4.1</a></span>
A statement sequence enclosed between a BEGIN and END reserved word pair is called a statement block. Statement blocks appear on module level and in procedure bodies.</div>
<div style="margin-left:63px"><span class="label"><a name="14449">2.9.4.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14450">2.9.4.2.1</a></span>
<pre><code>block = BEGIN StatementSequence END</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14363">2.9.5</a></span>
Assignments</h4>
<div style="margin-left:63px"><span class="label"><a name="14364">2.9.5.1</a></span>
Assignments replace the current value of a variable by a new value specified by an expression. The expression must be <i>assignment compatible</i> with the variable (see <a href="#14532">3 Definition of terms</a>). The assignment operator is written as <code>:=</code> and pronounced as <i>becomes</i>. </div>
<div style="margin-left:63px"><span class="label"><a name="14365">2.9.5.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14366">2.9.5.2.1</a></span>
<pre><code>assignment = designator ':=' expression</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14367">2.9.5.3</a></span>
If an expression <code>e</code> of type T<sub>e</sub> is assigned to a variable <code>v</code> of type T<sub>v</sub>, the following happens:</div>
<div style="margin-left:81px"><span class="label"><a name="14368">2.9.5.3.1</a></span>
if T<sub>v</sub> and T<sub>e</sub> are the same record types, all fields of T<sub>e</sub> are assigned to the corresponding fields of T<sub>v</sub>.</div>
<div style="margin-left:81px"><span class="label"><a name="14369">2.9.5.3.2</a></span>
if T<sub>v</sub> is <code>ARRAY n OF CHAR</code> and <code>e</code> is a string of length m &lt; n, <code>v[i]</code> becomes e<sub>i</sub> for i = 0..m-1 and <code>v[m]</code> becomes 0X;</div>
<div style="margin-left:63px"><span class="label"><a name="14372">2.9.5.4</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14373">2.9.5.4.1</a></span>
<pre><code>i := 0</code></pre>
<pre><code>p := i = j</code></pre>
<pre><code>x := i + 1</code></pre>
<pre><code>k := log2(i+j)</code></pre>
<pre><code>F := log2</code></pre>
<pre><code>s := {2, 3, 5, 7, 11, 13}</code></pre>
<pre><code>a[i] := (x+y) * (x-y)</code></pre>
<pre><code>t.key := i</code></pre>
<pre><code>w[i+1].name := &quot;John&quot;</code></pre>
<pre><code>t := c</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14374">2.9.6</a></span>
Procedure calls</h4>
<div style="margin-left:63px"><span class="label"><a name="14375">2.9.6.1</a></span>
A procedure call activates a procedure. It may contain a list of actual parameters which replace the corresponding formal parameter list defined in the procedure declaration (see <a href="#14440">2.11 Procedure declarations</a>). The correspondence is established by the positions of the parameters in the actual and formal parameter lists. </div>
<div style="margin-left:63px"><span class="label"><a name="14376">2.9.6.2</a></span>
Each actual parameter must be an expression. This expression is evaluated before the procedure activation, and the resulting value is assigned to the formal parameter (see also <a href="#14458">2.11.12 Formal parameters</a>). The order of evaluation of the actual parameter expressions is undefined.</div>
<div style="margin-left:63px"><span class="label"><a name="14377">2.9.6.3</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14378">2.9.6.3.1</a></span>
<pre><code>ProcedureCall = designator [ ActualParameters ]</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14379">2.9.6.4</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14380">2.9.6.4.1</a></span>
<pre><code>WriteInt(i*2+1)</code></pre>
<pre><code>inc(w[k].count)</code></pre>
<pre><code>t.Insert(&quot;John&quot;)</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14381">2.9.7</a></span>
<a href=""><b>I</b></a><b>f statements</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14382">2.9.7.1</a></span>
If statements specify the conditional execution of guarded statement sequences. The boolean expression preceding a statement sequence is called its guard. The guards are evaluated in sequence of occurrence, until one evaluates to TRUE, whereafter its associated statement sequence is executed. If no guard is satisfied, the statement sequence following ELSE is executed, if there is one.</div>
<div style="margin-left:63px"><span class="label"><a name="14383">2.9.7.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14384">2.9.7.2.1</a></span>
<pre><code>IfStatement    = IF expression THEN StatementSequence</code></pre>
<pre><code>	     {ElsifStatement} [ElseStatement] END</code></pre>
<pre><code>ElsifStatement = ELSIF expression THEN StatementSequence</code></pre>
<pre><code>ElseStatement  = ELSE StatementSequence</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14385">2.9.7.3</a></span>
Example:</div>
<div style="margin-left:81px"><span class="label"><a name="14386">2.9.7.3.1</a></span>
<pre><code>if (ch &gt;= &quot;A&quot;) &amp; (ch &lt;= &quot;Z&quot;) then ReadIdentifier</code></pre>
<pre><code>elsif (ch &gt;= &quot;0&quot;) &amp; (ch &lt;= &quot;9&quot;) then ReadNumber</code></pre>
<pre><code>elsif (ch = &quot;'&quot;) OR (ch = '&quot;') then ReadString</code></pre>
<pre><code>else SpecialCharacter</code></pre>
<pre><code>end</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14387">2.9.8</a></span>
<a href=""><b>C</b></a><b>ase statements</b></h4>
<div style="margin-left:63px"><span class="label"><a name="14388">2.9.8.1</a></span>
Case statements specify the selection and execution of a statement sequence according to the value of an expression. First the case expression is evaluated, then that statement sequence is executed whose case label list contains the obtained value. The case expression must either be of an integer type that includes the types of all case labels, or a constant enumeration type with all case labels being valid members of this type, or both the case expression and the case labels must be of type CHAR. Case labels are constants, and no value must occur more than once. If the value of the expression does not occur as a label of any case, the statement sequence following ELSE is selected, if there is one, otherwise the program is aborted.</div>
<div style="margin-left:63px"><span class="label"><a name="14389">2.9.8.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14390">2.9.8.2.1</a></span>
<pre><code>CaseStatement = CASE expression OF ['|'] Case { '|' Case }</code></pre>
<pre><code>	    [ ELSE StatementSequence ] END</code></pre>
<pre><code>Case          = [ CaseLabelList ':' StatementSequence ]</code></pre>
<pre><code>CaseLabelList = LabelRange { [','] LabelRange }</code></pre>
<pre><code>LabelRange    = label [ '..' label ]</code></pre>
<pre><code>label         = ConstExpression</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14391">2.9.8.3</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14392">2.9.8.3.1</a></span>
<pre><code>case ch of</code></pre>
<pre><code>  &quot;A&quot; .. &quot;Z&quot;: ReadIdentifier</code></pre>
<pre><code>| &quot;0&quot; .. &quot;9&quot;: ReadNumber</code></pre>
<pre><code>| &quot;'&quot;, '&quot;': ReadString</code></pre>
<pre><code>else SpecialCharacter</code></pre>
<pre><code>end</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14393">2.9.9</a></span>
While statements</h4>
<div style="margin-left:63px"><span class="label"><a name="14394">2.9.9.1</a></span>
While statements specify the repeated execution of a statement sequence while the Boolean expression (its guard) yields TRUE. The guard is checked before every execution of the statement sequence. </div>
<div style="margin-left:63px"><span class="label"><a name="14395">2.9.9.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14396">2.9.9.2.1</a></span>
<pre><code>WhileStatement = WHILE expression DO StatementSequence END</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14400">2.9.10</a></span>
Repeat statements</h4>
<div style="margin-left:63px"><span class="label"><a name="14401">2.9.10.1</a></span>
A repeat statement specifies the repeated execution of a statement sequence until a condition specified by a Boolean expression is satisfied. The statement sequence is executed at least once.</div>
<div style="margin-left:63px"><span class="label"><a name="14402">2.9.10.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14403">2.9.10.2.1</a></span>
<pre><code>RepeatStatement = REPEAT StatementSequence UNTIL expression</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14404">2.9.11</a></span>
For statements</h4>
<div style="margin-left:63px"><span class="label"><a name="14405">2.9.11.1</a></span>
A FOR statement specifies the repeated execution of a statement sequence while a progression of values is assigned to a control variable of the for statement. Control variables can be of integer or enumeration types. An explicit BY expression cannot be zero and is only supported for integer control variables.</div>
<div style="margin-left:63px"><span class="label"><a name="14406">2.9.11.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14407">2.9.11.2.1</a></span>
<pre><code>ForStatement = FOR ident ':=' expression TO expression</code></pre>
<pre><code>	   [BY ConstExpression]</code></pre>
<pre><code>	   DO StatementSequence END</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14408">2.9.11.3</a></span>
The statement</div>
<div style="margin-left:81px"><span class="label"><a name="14409">2.9.11.3.1</a></span>
<pre><code>for v := first to last by step do statements end</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14410">2.9.11.4</a></span>
is equivalent to</div>
<div style="margin-left:81px"><span class="label"><a name="14411">2.9.11.4.1</a></span>
<pre><code>temp := last; v := first</code></pre>
<pre><code>if step &gt; 0 then</code></pre>
<pre><code>    while v &lt;= temp do statements; INC(v,step) end</code></pre>
<pre><code>else</code></pre>
<pre><code>    while v &gt;= temp do statements; DEC(v,-step) end</code></pre>
<pre><code>end</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14412">2.9.11.5</a></span>
<i>temp</i> has the same type as <code>v</code>. <i>step</i> must be a nonzero constant expression; if <i>step</i> is not specified, it is assumed to be 1. </div>
<div style="margin-left:63px"><span class="label"><a name="17466">2.9.11.6</a></span><span class="ident">NOTE</span>
A FOR statement supposed to run downwards therefore needs an explicit negative BY expression.</div>
<div style="margin-left:63px"><span class="label"><a name="17464">2.9.11.7</a></span>
If <i>first</i> and <i>last</i> are elements of an enumeration type, then the statement is equivalent to</div>
<div style="margin-left:81px"><span class="label"><a name="17465">2.9.11.7.1</a></span>
<pre><code>temp := last; v := first</code></pre>
<pre><code>if ORD(first) &lt;= ORD(last) then</code></pre>
<pre><code>    while v &lt;= temp do statements; INC(v) end</code></pre>
<pre><code>else</code></pre>
<pre><code>    while v &gt;= temp do statements; DEC(v) end</code></pre>
<pre><code>end</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14413">2.9.11.8</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14414">2.9.11.8.1</a></span>
<pre><code>for i := 0 to 79 do k := k + a[i] end</code></pre>
<pre><code>for i := 79 to 1 by -1 do a[i] := a[i-1] end</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14415">2.9.12</a></span>
Loop statements</h4>
<div style="margin-left:63px"><span class="label"><a name="14416">2.9.12.1</a></span>
A loop statement specifies the repeated execution of a statement sequence. It is terminated upon execution of an exit statement within that sequence (see <a href="#14422">2.9.13 Return, exit and goto statements</a>).</div>
<div style="margin-left:63px"><span class="label"><a name="14417">2.9.12.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14418">2.9.12.2.1</a></span>
<pre><code>LoopStatement = LOOP StatementSequence END</code></pre>
<pre><code>ExitStatement = EXIT</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14419">2.9.12.3</a></span>
Example:</div>
<div style="margin-left:81px"><span class="label"><a name="14420">2.9.12.3.1</a></span>
<pre><code>loop</code></pre>
<pre><code>  ReadInt(i)</code></pre>
<pre><code>  if i &lt; 0 then exit end</code></pre>
<pre><code>  WriteInt(i)</code></pre>
<pre><code>end</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14421">2.9.12.4</a></span>
Loop statements are useful to express repetitions with several exit points or cases where the exit condition is in the middle of the repeated statement sequence.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14422">2.9.13</a></span>
Return, exit and goto statements</h4>
<div style="margin-left:63px"><span class="label"><a name="14423">2.9.13.1</a></span>
A return statement indicates the termination of a procedure. It is denoted by RETURN, followed by an expression if the procedure is a function procedure. The type of the expression must be assignment compatible (see <a href="#14532">3 Definition of terms</a>) with the result type specified in the procedure heading (see <a href="#14440">2.11 Procedure declarations</a>).</div>
<div style="margin-left:63px"><span class="label"><a name="14427">2.9.13.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14428">2.9.13.2.1</a></span>
<pre><code>ReturnStatement = RETURN [ expression ]</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14424">2.9.13.3</a></span>
Function procedures require the presence of a return statement indicating the result value. In proper procedures, a return statement is implied by the end of the procedure body. Any explicit return statement therefore appears as an additional (probably exceptional) termination point.</div>
<div style="margin-left:63px"><span class="label"><a name="14425">2.9.13.4</a></span><span class="ident">NOTE</span>
The optional expression causes an LL(k) ambiguity which can be resolved in that the parser expects a return expression if the procedure has a return type and vice versa. </div>
<div style="margin-left:63px"><span class="label"><a name="14426">2.9.13.5</a></span>
An exit statement is denoted by EXIT. It specifies termination of the enclosing loop statement and continuation with the statement following that loop statement. Exit statements are contextually, although not syntactically associated with the loop statement which contains them.</div>
<div style="margin-left:63px"><span class="label"><a name="14429">2.9.13.6</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14430">2.9.13.6.1</a></span>
<pre><code>ExitStatement   = EXIT</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14444">2.9.13.7</a></span>
The goto statement causes an unconditional jump to another statement in the same block (see <a href="#14447">2.9.4 Statement block</a>). The destination of the jump is specified by the name of a label. Goto labels are declared in the statement sequence and are referenced in the goto statements. It is illegal to define a label that is never used. Goto labels do not conflict with identifiers that are not labels. The scope of a goto label is the enclosing block. </div>
<div style="margin-left:63px"><span class="label"><a name="14445">2.9.13.8</a></span>
A goto statement cannot jump into a structured statement or outside of the enclosing block.</div>
<div style="margin-left:63px"><span class="label"><a name="14432">2.9.13.9</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14433">2.9.13.9.1</a></span>
<pre><code>GotoStatement = 'GOTO' ident</code></pre>
<pre><code>gotoLabel = ident ':'</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14446">2.9.13.10</a></span><span class="ident">NOTE</span>
Goto statements are considered bad practice and should be avoided as much as possible. They were mostly added to the language to ease migration of existing C code. It is always possible to replace a goto statement by an alternative implementation that doesn’t need a goto.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14434">2.10</a></span>
Exception handling</h4>
<div style="margin-left:45px"><span class="label"><a name="14435">2.10.1</a></span>
Exception handling in Micron is implemented using the predeclared procedures PCALL and RAISE (see <a href="#14136">6 Predeclared Procedure Reference</a>), without any special syntax. There are no predefined exceptions.</div>
<div style="margin-left:45px"><span class="label"><a name="14436">2.10.2</a></span>
An exception is just a value of type POINTER TO ANY. The pointer representing the exception is passed as an actual argument to RAISE. RAISE may be called without an argument in which case the compiler provides a random internal pointer. RAISE never returns, but control is transferred from the place where RAISE is called to the nearest dynamically-enclosing call of PCALL. When calling RAISE without a dynamically-enclosing call of PCALL the program execution is aborted.</div>
<div style="margin-left:45px"><span class="label"><a name="14437">2.10.3</a></span>
PCALL executes a protected call of the procedure or procedure type P. P is passed as the second argument to PCALL. P cannot have a return type. P can be a nested procedure. If P has formal parameters the corresponding actual parameters are passed to PCALL immediately after P. The actual parameters must be <i>parameter compatible</i> with the formal parameters of P (see <a href="#14532">3 Definition of terms</a>). The first parameter R of PCALL is a variable of type POINTER TO ANY; if RAISE(E) is called in the course of P, then R is set to E; otherwise R is set to NIL. The state of VAR parameters of P or local variables or parameters of an outer procedure accessed by P is non-deterministic in case RAISE is called in the course of P.</div>
<div style="margin-left:45px"><span class="label"><a name="14438">2.10.4</a></span>
Example:</div>
<div style="margin-left:63px"><span class="label"><a name="14439">2.10.4.1</a></span>
<pre><code>module ExceptionExample</code></pre>
<pre><code>  var ex1, ex2: integer // type doesn't matter</code></pre>
<pre><code>  proc Print(in str: array of char)</code></pre>
<pre><code>  begin</code></pre>
<pre><code>    println(str)</code></pre>
<pre><code>    raise(@ex1)</code></pre>
<pre><code>    println(&quot;this is not printed&quot;)</code></pre>
<pre><code>  end Print</code></pre>
<pre><code>  var res: pointer to any</code></pre>
<pre><code>begin</code></pre>
<pre><code>  pcall(res, Print, &quot;Hello World&quot;)</code></pre>
<pre><code>  if res = @ex1 then println(&quot;got ex1&quot;)</code></pre>
<pre><code>  elsif res = nil then println(&quot;no exception&quot;)</code></pre>
<pre><code>  else println(&quot;unknown exception&quot;)</code></pre>
<pre><code>    // could call raise(res) here to propagate the exception</code></pre>
<pre><code>  end</code></pre>
<pre><code>end ExceptionExample</code></pre></div>
<h4 style="margin-left:27px"><span class="label"><a name="14440">2.11</a></span>
<a href=""><b>P</b></a><b>rocedure declarations</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14441">2.11.1</a></span>
A procedure declaration consists of a procedure heading and a procedure body. The heading specifies the procedure identifier and the formal parameters (see <a href="#14458">2.11.12 Formal parameters</a>). The body contains declarations and statements. The procedure identifier must be repeated at the end of the procedure declaration.</div>
<div style="margin-left:45px"><span class="label"><a name="14452">2.11.2</a></span>
There are two kinds of procedures: proper procedures and function procedures. The latter are activated by a function designator as a constituent of an expression and yield a result that is an operand of the expression. Proper procedures are activated by a procedure call. A procedure is a function procedure if its formal parameters specify a result type. Each control path of a function procedure must return a value.</div>
<div style="margin-left:45px"><span class="label"><a name="14453">2.11.3</a></span>
All constants, variables, types, and procedures declared within a procedure body are local to the procedure. The values of local variables are undefined upon entry to the procedure. Since procedures may be declared as local objects too, procedure declarations may be nested. The call of a procedure within its declaration implies recursive activation.</div>
<div style="margin-left:45px"><span class="label"><a name="15599">2.11.4</a></span>
In addition to its formal parameters and locally declared objects, the objects declared globally are also visible in the procedure.</div>
<div style="margin-left:45px"><span class="label"><a name="14485">2.11.5</a></span>
A procedure can be declared INLINE in which case the code of the procedure is embedded at the call site, and no call actually happens. Procedures declared INLINE don't support  recursion, neither directly nor indirectly. INLINE procedures neither support variable length array local variables. Nested procedures of an INLINE procedure must also be INLINE.</div>
<div style="margin-left:45px"><span class="label"><a name="14486">2.11.6</a></span>
A procedure can be declared INVAR (invariable) in which case it can be used in CONST declarations to derive a constant value at compile time. INVAR procedures can only call other INVAR procedures or predeclared procedures not depending on runtime information. INVAR procedures cannot access module variables, but they can access CONST declarations in the same or other modules.</div>
<div style="margin-left:45px"><span class="label"><a name="15572">2.11.7</a></span>
A procedure can be declared EXTERN to indicate that it is implemented in an external library with C calling conventions. EXTERN can be followed by the name the procedure has in that external library, otherwise the same name as in the identdef is assumed. </div>
<div style="margin-left:45px"><span class="label"><a name="15795">2.11.8</a></span><span class="ident">NOTE</span>
EXTERN is regarded as an alternative to ProcedureBody, why it follows the (optional) semicolon. </div>
<div style="margin-left:45px"><span class="label"><a name="15362">2.11.9</a></span>
A procedure can be forward declared in which case the formal parameters must be identical with the actual procedure declaration. Forward declarations are marked by '^'.</div>
<div style="margin-left:45px"><span class="label"><a name="15363">2.11.10</a></span>
A procedure can be an alias of another procedure. The other procedure is referenced with a qualident. If the other procedure is in another module, it must be exported.</div>
<div style="margin-left:45px"><span class="label"><a name="14456">2.11.11</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14457">2.11.11.1</a></span>
<pre><code>ProcedureDeclaration = ProcedureHeading ( [ INLINE | INVAR ] [';'] ProcedureBody <br />                                        | [';'] EXTERN [ident] ) <br />                       | ( PROCEDURE | PROC ) '^' identdef [ FormalParameters ]<br />                                        [ INLINE | INVAR | EXTERN ]<br />                       | ( PROCEDURE | PROC ) identdef '=' qualident<br /><br />ProcedureHeading     = ( PROCEDURE | PROC ) identdef [ FormalParameters ]<br /><br />ProcedureBody        = DeclarationSequence BEGIN StatementSequence END ident</code></pre>
<pre><code>DeclarationSequence  = { CONST { ConstDeclaration [';'] }</code></pre>
<pre><code>	           | TypeDeclarationSection</code></pre>
<pre><code>	           | VAR { VariableDeclaration [';'] }</code></pre>
<pre><code>	           | ProcedureDeclaration [';'] }<br /><br />TypeDeclarationSection = TYPE { TypeDeclaration [';'] }</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14458">2.11.12</a></span>
Formal parameters</h4>
<div style="margin-left:63px"><span class="label"><a name="14459">2.11.12.1</a></span>
Formal parameters are identifiers declared in the formal parameter list of a procedure. They correspond to actual parameters specified in the procedure call. The correspondence between formal and actual parameters is established when the procedure is called. </div>
<div style="margin-left:63px"><span class="label"><a name="14484">2.11.12.2</a></span><span class="ident">NOTE</span>
Oberon and Oberon+ support VAR parameters, which are not necessary in Micron, because the formal parameter can be a pointer instead and the '@' operator can be applied to the designator passed as actual parameter.</div>
<div style="margin-left:63px"><span class="label"><a name="14483">2.11.12.3</a></span>
The scope of a formal parameter extends from its declaration to the end of the procedure block in which it is declared. A function procedure without parameters must have an empty parameter list. It must be called by a function designator whose actual parameter list is empty too. </div>
<div style="margin-left:63px"><span class="label"><a name="14488">2.11.12.4</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14489">2.11.12.4.1</a></span>
<pre><code>FormalParameters = '(' [ FPSection { [';'] FPSection } [ [';'] '..'] ] ')'</code></pre>
<pre><code>                   [ ':' ReturnType ]</code></pre>
<pre><code>ReturnType       = [ POINTER TO | '^' ] NamedType</code></pre>
<pre><code>FPSection        = [CONST] ident { [','] ident } ':' FormalType</code></pre>
<pre><code>FormalType       = type</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="15961">2.11.12.5</a></span>
Let T<sub>f</sub> be the type of a formal parameter <code>f</code> and T<sub>a</sub> the type of the corresponding actual parameter <code>a</code>. T<sub>a</sub> must be <i>parameter compatible</i> to <code>f</code> (see <a href="#14532">3 Definition of terms</a>).</div>
<div style="margin-left:63px"><span class="label"><a name="16021">2.11.12.6</a></span>
CONST parameters are read-only in the procedure body. The read-only feature is transitive, i.e. also the variables, elements or fields designated from a CONST parameter are read-only. </div>
<div style="margin-left:63px"><span class="label"><a name="14490">2.11.12.7</a></span>
Procedures can have a variable number of parameters, which is indicated by '..' (ellipsis). In that case the additional parameters (called &quot;variable parameters&quot;) can be accessed in the procedure body using the VARARG() and VARARGS() predeclared procedures. Only actual parameters of basic or pointer type (including enumerations and procedure types) can be passed as variable parameters.</div>
<div style="margin-left:63px"><span class="label"><a name="14491">2.11.12.8</a></span>
Examples:</div>
<div style="margin-left:81px"><span class="label"><a name="14492">2.11.12.8.1</a></span>
<pre><code>proc ReadInt(x: pointer to integer)</code></pre>
<pre><code>  var i: integer; ch: char</code></pre>
<pre><code>begin i := 0; Read(ch)</code></pre>
<pre><code>  while (&quot;0&quot; &lt;= ch) &amp; (ch &lt;= &quot;9&quot;) do</code></pre>
<pre><code>    i := 10*i + (ord(ch)-ord(&quot;0&quot;)); Read(ch)</code></pre>
<pre><code>  end</code></pre>
<pre><code>  x^ := i</code></pre>
<pre><code>end ReadInt</code></pre></div>
<h4 style="margin-left:45px"><span class="label"><a name="14493">2.11.13</a></span>
Predeclared procedures</h4>
<div style="margin-left:63px"><span class="label"><a name="14495">2.11.13.1</a></span>
Predeclared procedures are provided by the compiler and accessible without extra imports. Some are generic procedures, i.e. they apply to several types of operands.</div>
<div style="margin-left:63px"><span class="label"><a name="14494">2.11.13.2</a></span>
See <a href="#14136">6 Predeclared Procedure Reference</a> for the list of predeclared procedures each Micron compiler has to provide.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14498">2.12</a></span>
Modules</h4>
<div style="margin-left:45px"><span class="label"><a name="14499">2.12.1</a></span>
A module is a collection of declarations of constants, types, variables, and procedures, together with a sequence of statements for the purpose of assigning initial values to the variables. A module constitutes a text that is compilable as a unit (compilation unit).</div>
<div style="margin-left:45px"><span class="label"><a name="14500">2.12.2</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14501">2.12.2.1</a></span>
<pre><code>module     = MODULE ident [ MetaParams ] [';']</code></pre>
<pre><code>             { ImportList | DeclarationSequence }</code></pre>
<pre><code>	 [ BEGIN StatementSequence ] END ident ['.']</code></pre>
<pre><code>ImportList = IMPORT import { [','] import } [';']</code></pre>
<pre><code>import     = [ ident ':=' ] ImportPath ident [ MetaActuals ]</code></pre>
<pre><code>ImportPath = { ident '.' }</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14502">2.12.3</a></span>
The import list specifies the names of the imported modules. If a module A is imported by a module M and A exports an identifier <code>x</code>, then <code>x</code> is referred to as <code>A.x</code> within M.</div>
<div style="margin-left:45px"><span class="label"><a name="14503">2.12.4</a></span>
If A is imported as <code>B := A</code>, the object <code>x</code> must be referenced as <code>B.x</code>. This allows short alias names in qualified identifiers.</div>
<div style="margin-left:45px"><span class="label"><a name="14504">2.12.5</a></span>
In Micron, as in Oberon+, the import can refer to a module by means of a module name optionally prefixed with an import path. There is no requirement that the import path actually exists in the file system, or that the source files corresponding to an import path are in the same file system directory. It is up to the compiler how source files are mapped to import paths. An imported module with no import path is first looked up in the import path of the importing module.</div>
<div style="margin-left:45px"><span class="label"><a name="14505">2.12.6</a></span>
A module must not import itself (neither directly nor indirectly).</div>
<div style="margin-left:45px"><span class="label"><a name="14506">2.12.7</a></span>
Identifiers that are to be exported (i.e. that are to be visible in client modules) must be marked by an export mark in their declaration (see Chapter <a href="#14160">2.4 Declarations and scope rules</a>).</div>
<div style="margin-left:45px"><span class="label"><a name="14507">2.12.8</a></span>
The statement sequence following the symbol BEGIN is executed when the module is loaded, which is done after the imported modules have been loaded. It follows that cyclic import of modules is illegal.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14508">2.13</a></span>
Generics</h4>
<div style="margin-left:45px"><span class="label"><a name="14509">2.13.1</a></span>
Micron, as Oberon+, supports generic programming. Modules can be made generic by adding formal meta parameters. Meta parameters represent types or constants; the latter include procedures. Meta parameters default to types, but can be explicitly prefixed with the TYPE reserved word; the CONST prefix designates a constant meta parameter. A CONST meta parameter can be constrained with a named type using a special form of the ConstDeclaration, in which case the actual meta parameter must correspond to this type; the correspondence is established when the generic module is instantiated; the type of the actual meta parameter must be assignment compatible with the constraint type (see <a href="#14532">3 Definition of terms</a>). The special form of the ConstDeclaration may only used for a CONST meta parameter with the same ident.</div>
<div style="margin-left:45px"><span class="label"><a name="14510">2.13.2</a></span>
Generic modules can be instantiated with different sets of meta actuals which enables the design of reusable algorithms and data structures. The instantiation of a generic module occurs when importing it. A generic module can be instantiated more than once in the same module with different actual meta parameters. See also <a href="#14498">2.12 Modules</a>.</div>
<div style="margin-left:45px"><span class="label"><a name="14511">2.13.3</a></span>
Syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14512">2.13.3.1</a></span>
<pre><code>MetaParams       = '(' MetaSection { [';'] MetaSection } ')'</code></pre>
<pre><code>MetaSection      = ['CONST' | 'TYPE'] ident { [','] ident } [ ':' NamedType ]<br />ConstDeclaration = identdef ':' NamedType</code></pre>
<pre><code>TypeConstraint   = NamedType</code></pre>
<pre><code>MetaActuals      = '(' ConstExpression { [','] ConstExpression } ')'</code></pre></div>
<div style="margin-left:45px"><span class="label"><a name="14513">2.13.4</a></span>
Meta parameters can be used within the generic module like normal types or constants. If no type constraint is present, the types and constants can be used wherever no information about the actual type is required; otherwise the type constraint determines the permitted operations. The rules for <i>same types</i> and <i>equal types</i> apply analogously to meta parameters, and subsequently also the corresponding assignment, parameter and array compatibility rules.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14514">2.14</a></span>
Source code directives</h4>
<div style="margin-left:45px"><span class="label"><a name="14515">2.14.1</a></span>
Source code directives are used to set configuration variables in the source text and to select specific pieces of the source text to be compiled (conditional compilation). Oberon+ uses the syntax recommended in <a href="#14629">7.2 Kirk, B. et al. (1995). The Oakwood Guidelines...</a>.</div>
<h4 style="margin-left:45px"><span class="label"><a name="14516">2.14.2</a></span>
Configuration Variables</h4>
<div style="margin-left:63px"><span class="label"><a name="14517">2.14.2.1</a></span>
Configuration variables can be set or unset in the source code using the following syntax:</div>
<div style="margin-left:63px"><span class="label"><a name="14518">2.14.2.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14519">2.14.2.2.1</a></span>
<pre><code>directive = '&lt;*' ident ( '+' | '-' ) '*&gt;'</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14520">2.14.2.3</a></span>
Each variable is named by an ident which follows the syntax specified in <a href="#14168">2.3.4 Identifiers</a>. Variable names have compilation unit scope which is separate from all other scopes of the program. Configuration variable directives can be placed anywhere in the source code. The directive only affects the present compilation unit, starting from its position in the source code.</div>
<div style="margin-left:63px"><span class="label"><a name="14521">2.14.2.4</a></span>
Example:</div>
<div style="margin-left:81px"><span class="label"><a name="14522">2.14.2.4.1</a></span>
<pre><code>&lt;* WIN32+ *&gt;</code></pre>
<pre><code>&lt;* WIN64- *&gt;</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14523">2.14.2.5</a></span><span class="ident">NOTE</span>
Usually the compiler provides the possibility to set configuration variables, e.g. via command line interface. </div>
<div style="margin-left:63px"><span class="label"><a name="14524">2.14.2.6</a></span>
TBD: import configuration files with a list of flags for project wide configuration</div>
<h4 style="margin-left:45px"><span class="label"><a name="14525">2.14.3</a></span>
Conditional compilation</h4>
<div style="margin-left:63px"><span class="label"><a name="14526">2.14.3.1</a></span>
Conditional compilation directives can be placed anywhere in the source code. The following syntax applies:</div>
<div style="margin-left:63px"><span class="label"><a name="14527">2.14.3.2</a></span>
Syntax:</div>
<div style="margin-left:81px"><span class="label"><a name="14528">2.14.3.2.1</a></span>
<pre><code>directive  = '&lt;*' [ scIf | scElsif | scElse | scEnd ] '*&gt;'</code></pre>
<pre><code>scIf       = IF scExpr THEN</code></pre>
<pre><code>scElsif    = ELSIF condition THEN</code></pre>
<pre><code>scElse     = ELSE</code></pre>
<pre><code>scEnd      = END</code></pre>
<pre><code>condition  = scTerm { OR scTerm }</code></pre>
<pre><code>scTerm     = scFactor {'&amp;' scFactor}</code></pre>
<pre><code>scFactor   = ident | '(' condition ')' | '~' scFactor</code></pre></div>
<div style="margin-left:63px"><span class="label"><a name="14529">2.14.3.3</a></span>
An ELSIF or ELSE directive must be preceded by an IF or another ELSIF directive. Each IF directive must be ended by an END directive. The directives form sections of the source code. Only the section the condition of which is TRUE (or the section framed by ELSE and END directive otherwise) is visible to the compiler. Conditions are boolean expressions. Ident refers to a configuration variable. When a configuration variable is not explicitly set it is assumed to be FALSE. Each section can contain nested conditional compilation directives.</div>
<div style="margin-left:63px"><span class="label"><a name="14530">2.14.3.4</a></span>
Example:</div>
<div style="margin-left:81px"><span class="label"><a name="14531">2.14.3.4.1</a></span>
<pre><code>&lt;* if A then *&gt;</code></pre>
<pre><code>  println(&quot;A&quot;)</code></pre>
<pre><code>&lt;* elsif B &amp; ~C then *&gt;</code></pre>
<pre><code>  println(&quot;B &amp; ~C&quot;)</code></pre>
<pre><code>&lt;* else *&gt;</code></pre>
<pre><code>  println(&quot;D&quot;)</code></pre>
<pre><code>&lt;* end *&gt;</code></pre></div>
<h4 style="margin-left:9px"><span class="label"><a name="14532">3</a></span>
Definition of terms</h4>
<h4 style="margin-left:27px"><span class="label"><a name="14533">3.1</a></span>
Integer types</h4>
<div style="margin-left:45px"><span class="label"><a name="14534">3.1.1</a></span>
<a href="#14535">Signed integer types</a>, <a href="#14537">Unsigned integer types</a></div>
<h4 style="margin-left:27px"><span class="label"><a name="14535">3.2</a></span>
Signed integer types</h4>
<div style="margin-left:45px"><span class="label"><a name="14536">3.2.1</a></span>
<a href="#14676">INT8, INT16, INT32, INT64, SHORTINT, INTEGER, LONG...</a></div>
<h4 style="margin-left:27px"><span class="label"><a name="14537">3.3</a></span>
Unsigned integer types</h4>
<div style="margin-left:45px"><span class="label"><a name="14538">3.3.1</a></span>
<a href="#14678">BYTE, UINT8, UINT16, UINT32, UINT64</a></div>
<h4 style="margin-left:27px"><span class="label"><a name="14539">3.4</a></span>
<b>Floating-point types</b></h4>
<div style="margin-left:45px"><span class="label"><a name="14682">3.4.1</a></span>
<a href="#14680">REAL, LONGREAL, F32, F64</a></div>
<h4 style="margin-left:27px"><span class="label"><a name="14541">3.5</a></span>
Numeric types</h4>
<div style="margin-left:45px"><span class="label"><a name="14542">3.5.1</a></span>
<a href="#14533">Integer types</a>, <a href="#14539">Floating-point types</a></div>
<h4 style="margin-left:27px"><span class="label"><a name="14543">3.6</a></span>
Same types</h4>
<div style="margin-left:45px"><span class="label"><a name="14544">3.6.1</a></span>
Two variables a and b with types T<sub>a</sub> and T<sub>b</sub> are of the same type if</div>
<div style="margin-left:63px"><span class="label"><a name="14545">3.6.1.1</a></span>
T<sub>a</sub> and T<sub>b</sub> are both denoted by the same type identifier, or</div>
<div style="margin-left:63px"><span class="label"><a name="14546">3.6.1.2</a></span>
T<sub>a</sub> is declared to equal T<sub>b</sub> in a type declaration of the form T<sub>a</sub> = T<sub>b</sub>, or</div>
<div style="margin-left:63px"><span class="label"><a name="14547">3.6.1.3</a></span>
a and b appear in the same identifier list in a variable, record field, or formal parameter declaration and are not open arrays.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14548">3.7</a></span>
Equal types</h4>
<div style="margin-left:45px"><span class="label"><a name="14549">3.7.1</a></span>
Two types T<sub>a</sub> and T<sub>b</sub> are equal if</div>
<div style="margin-left:63px"><span class="label"><a name="14550">3.7.1.1</a></span>
T<sub>a</sub> and T<sub>b</sub> are the <i>same type</i>, or</div>
<div style="margin-left:63px"><span class="label"><a name="15996">3.7.1.2</a></span>
T<sub>a</sub> and T<sub>b</sub> are open array types with <i>equal element types</i>, or</div>
<div style="margin-left:63px"><span class="label"><a name="16051">3.7.1.3</a></span>
T<sub>a</sub> and T<sub>b</sub> are non-open array types with same length and <i>equal element types</i>, or</div>
<div style="margin-left:63px"><span class="label"><a name="16052">3.7.1.4</a></span>
T<sub>a</sub> and T<sub>b</sub> are pointer types with <i>equal base types</i>, or</div>
<div style="margin-left:63px"><span class="label"><a name="14552">3.7.1.5</a></span>
T<sub>a</sub> and T<sub>b</sub> are procedure types whose formal parameters <i>match</i></div>
<h4 style="margin-left:27px"><span class="label"><a name="14554">3.8</a></span>
Type inclusion</h4>
<div style="margin-left:45px"><span class="label"><a name="14555">3.8.1</a></span>
Numeric types include (the values of) smaller numeric types. There is a separate type inclusion hierarchy for signed integeres, unsigned integers and floating point types. See <a href="#14224">2.6.4 Basic types</a> for more information.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14556">3.9</a></span>
Assignment compatible</h4>
<div style="margin-left:45px"><span class="label"><a name="14557">3.9.1</a></span>
An expression e of type T<sub>e</sub> is assignment compatible with a variable v of type T<sub>v</sub> if one of the following conditions hold:</div>
<div style="margin-left:63px"><span class="label"><a name="14558">3.9.1.1</a></span>
T<sub>e</sub> and T<sub>v</sub> are the <i>same type</i>;</div>
<div style="margin-left:63px"><span class="label"><a name="14559">3.9.1.2</a></span>
T<sub>e</sub> and T<sub>v</sub> are numeric types and T<sub>v</sub> <i>includes</i> T<sub>e</sub>;</div>
<div style="margin-left:63px"><span class="label"><a name="14564">3.9.1.3</a></span>
T<sub>e</sub> and T<sub>v</sub> are pointer types and the pointers have <i>equal</i> base types;</div>
<div style="margin-left:63px"><span class="label"><a name="16056">3.9.1.4</a></span>
T<sub>e</sub> and T<sub>v</sub> are non-open array types with the same length and have <i>equal</i> base types;</div>
<div style="margin-left:63px"><span class="label"><a name="15999">3.9.1.5</a></span>
T<sub>v</sub> is a pointer to a one dimensional open array, T<sub>e</sub> is a pointer to any one or more dimensional array, and their element types are <i>equal;</i></div>
<div style="margin-left:63px"><span class="label"><a name="16002">3.9.1.6</a></span>
T<sub>v</sub> is a pointer to a record T<sub>R </sub>and T<sub>e</sub> is a pointer to a record the first field of which is of type T<sub>R</sub>, or is again a record the first field of which is of type T<sub>R</sub>.</div>
<div style="margin-left:63px"><span class="label"><a name="14565">3.9.1.7</a></span>
T<sub>v</sub> is a pointer or a procedure type and <code>e</code> is NIL;</div>
<div style="margin-left:63px"><span class="label"><a name="17335">3.9.1.8</a></span>
T<sub>e</sub> and T<sub>v</sub> are procedure types whose formal parameters <i>match</i>;</div>
<div style="margin-left:63px"><span class="label"><a name="15964">3.9.1.9</a></span>
T<sub>e</sub> and T<sub>v</sub> are pointer types and T<sub>v</sub> is a pointer to ANY;</div>
<div style="margin-left:63px"><span class="label"><a name="14672">3.9.1.10</a></span>
T<sub>v</sub> is an enumeration type and <code>e</code> is a valid element of the enumeration;</div>
<div style="margin-left:63px"><span class="label"><a name="14567">3.9.1.11</a></span>
T<sub>v</sub> is a non-open array of CHAR, T<sub>e</sub> is a string, and STRLEN(e) &lt; LEN(v);</div>
<div style="margin-left:63px"><span class="label"><a name="14568">3.9.1.12</a></span>
T<sub>v</sub> is a procedure type and <code>e</code> is the name of a procedure whose formal parameters <i>match</i> those of T<sub>v</sub>.</div>
<div style="margin-left:63px"><span class="label"><a name="16003">3.9.1.13</a></span>
T<sub>v</sub> is a signed integer and <code>e</code> is an unsigned integer constant, and T<sub>v</sub> <i>includes</i> the smallest integer type necessary to represent <code>e</code>.</div>
<div style="margin-left:45px"><span class="label"><a name="16053">3.9.2</a></span><span class="ident">NOTE</span>
Also remember <a href="#16054">2.3.7.2</a>.</div>
<h4 style="margin-left:27px"><span class="label"><a name="14569">3.10</a></span>
Parameter compatible</h4>
<div style="margin-left:45px"><span class="label"><a name="14570">3.10.1</a></span>
An actual parameter <code>a</code> of type T<sub>a</sub> is parameter compatible with a formal parameter <code>f</code> of type T<sub>f</sub> if</div>
<div style="margin-left:63px"><span class="label"><a name="14571">3.10.1.1</a></span>
T<sub>f</sub> and T<sub>a</sub> are <i>equal</i> types, or</div>
<div style="margin-left:63px"><span class="label"><a name="16022">3.10.1.2</a></span>
T<sub>f</sub> is a pointer to an open array of CHAR, <code>f</code> is CONST, and <code>a</code> is string literal, or</div>
<div style="margin-left:63px"><span class="label"><a name="14572">3.10.1.3</a></span>
T<sub>a</sub> is <i>assignment compatible</i> with T<sub>f</sub></div>
<h4 style="margin-left:27px"><span class="label"><a name="14579">3.11</a></span>
Expression compatible</h4>
<div style="margin-left:45px"><span class="label"><a name="14580">3.11.1</a></span>
For a given operator, the types of its operands are expression compatible if they conform to the following table (which shows also the result type of the expression). CHAR arrays that are to be compared must contain 0X as a terminator. </div>
<div style="margin-left:45px"><span class="label"><a name="14583">3.11.2</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 ><thead>
<tr>
<td>
<b>operator</b></td>
<td>
<br><b>first operand</b></td>
<td>
<br><b>second operand</b></td>
<td>
<br><b>result type</b></td></tr></thead>
<tr>
<td>
<br>+ - *</td>
<td>
<br>signed integer</td>
<td>
<br>signed integer</td>
<td>
<br>smallest signed integer type including both operands</td></tr>
<tr>
<td></td>
<td>
<br>unsigned integer</td>
<td>
<br>unsigned integer</td>
<td>
<br>smallest unsigned integer type including both operands</td></tr>
<tr>
<td></td>
<td>
<br>floating point</td>
<td>
<br>floating point</td>
<td>
<br>smallest floating point type including both operands</td></tr>
<tr>
<td>
<br>/</td>
<td>
<br>numeric</td>
<td>
<br>numeric</td>
<td>
<br>smallest floating point type type including both operands</td></tr>
<tr>
<td>
<br>+ - * /</td>
<td>
<br>SET</td>
<td>
<br>SET</td>
<td>
<br>SET</td></tr>
<tr>
<td>
<br>DIV MOD</td>
<td>
<br>signed integer</td>
<td>
<br>signed integer</td>
<td>
<br>smallest signed integer type type including both operands</td></tr>
<tr>
<td></td>
<td>
<br>unsigned integer</td>
<td>
<br>unsigned integer</td>
<td>
<br>smallest unsigned integer type type including both operands</td></tr>
<tr>
<td>
<br>OR &amp; ~</td>
<td>
<br>BOOLEAN</td>
<td>
<br>BOOLEAN</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td>
<br>= # &lt; ⇐ &gt; &gt;=</td>
<td>
<br>signed integer</td>
<td>
<br>signed integer</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>unsignednteger</td>
<td>
<br>unsigned integer</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>floating point</td>
<td>
<br>floating point</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>CHAR</td>
<td>
<br>CHAR</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>CHAR array, string</td>
<td>
<br>CHAR array, string</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td>
<br>= #</td>
<td>
<br>BOOLEAN</td>
<td>
<br>BOOLEAN</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>SET</td>
<td>
<br>SET</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>NIL, pointer type</td>
<td>
<br>NIL, pointer type</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td></td>
<td>
<br>procedure type, NIL</td>
<td>
<br>procedure type, NIL</td>
<td>
<br>BOOLEAN</td></tr>
<tr>
<td>
<br>IN</td>
<td>
<br>integer</td>
<td>
<br>SET</td>
<td>
<br>BOOLEAN</td></tr></table></div>
<h4 style="margin-left:27px"><span class="label"><a name="14582">3.12</a></span>
Matching formal parameter lists</h4>
<div style="margin-left:45px"><span class="label"><a name="14584">3.12.1</a></span>
Two formal parameter lists match if</div>
<div style="margin-left:63px"><span class="label"><a name="14585">3.12.1.1</a></span>
they have the same number of parameters, and</div>
<div style="margin-left:63px"><span class="label"><a name="14586">3.12.1.2</a></span>
parameters at corresponding positions have <i>equal types</i>, and</div>
<div style="margin-left:63px"><span class="label"><a name="16035">3.12.1.3</a></span>
parameters at corresponding positions are both either CONST or not, and</div>
<div style="margin-left:63px"><span class="label"><a name="14587">3.12.1.4</a></span>
both parameter lists either end with an ellipsis or not</div>
<h4 style="margin-left:27px"><span class="label"><a name="14588">3.13</a></span>
Matching result types</h4>
<div style="margin-left:45px"><span class="label"><a name="14589">3.13.1</a></span>
The result types of two procedures match if they are either the <i>same type</i> or none.</div>
<h4 style="margin-left:9px"><span class="label"><a name="14590">4</a></span>
<b>Complete Micron Syntax</b></h4>
<div style="margin-left:27px"><span class="label"><a name="14592">4.1</a></span><a href="#14171">&#x21B3;</a>
<pre><code>ident  = ( letter | '_' ) { letter | digit | '_' }</code></pre>
<pre><code>letter = 'A' ... 'Z' | 'a' ... 'z'</code></pre>
<pre><code>digit  = '0' ... '9'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14593">4.2</a></span><a href="#14178">&#x21B3;</a>
<pre><code>number   = integer | real</code></pre>
<pre><code>integer  = (digit {digit|'_'} ['O'|'B'] | digit {hexDigit|'_'} 'H')<br />           ['U'|'U1'|'U2'|'U4'|'U8'|'I'|'I1'|'I2'|'I4'|'I8']</code></pre>
<pre><code>real     = digit {digit|'_'} '.' {digit} [Exponent]</code></pre>
<pre><code>Exponent = ('E' | 'D' | 'F' ) ['+' | '-'] digit {digit}</code></pre>
<pre><code>hexDigit = digit | 'A' ... 'F'</code></pre>
<pre><code>digit    = '0' ... '9'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14594">4.3</a></span><a href="#14184">&#x21B3;</a>
<pre><code>character = digit {hexDigit} ('X' | 'x')</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14595">4.4</a></span><a href="#14189">&#x21B3;</a>
<pre><code>string = ''' {character} ''' | '&quot;' {character} '&quot;'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14597">4.5</a></span><a href="#14207">&#x21B3;</a>
<pre><code>qualident = [ident '.'] ident</code></pre>
<pre><code>identdef  = ident ['*' | '-']</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14598">4.6</a></span><a href="#14213">&#x21B3;</a>
<pre><code>ConstDeclaration = identdef '=' ConstExpression</code></pre>
<pre><code>ConstExpression  = expression</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14599">4.7</a></span><a href="#14221">&#x21B3;</a>
<pre><code>TypeDeclaration = identdef '=' type</code></pre>
<pre><code>type            = NamedType | ArrayType | RecordType | PointerType | ProcedureType | enumeration</code></pre>
<pre><code>NamedType       = qualident</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14600">4.8</a></span><a href="#14262">&#x21B3;</a>
<pre><code>ArrayType  = ARRAY [ length ] OF type | '[' [ length ] ']' type</code></pre>
<pre><code>length     = ConstExpression | VAR varlength</code></pre>
<pre><code>varlength  = expression</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14601">4.9</a></span><a href="#14275">&#x21B3;</a>
<pre><code>RecordType = RECORD [FixedPart][VariantPart] END</code></pre>
<pre><code>FixedPart = FieldList { [';'] FieldList}</code></pre>
<pre><code>FieldList  = [ IdentList ':' type ] | INLINE identdef ':' type</code></pre>
<pre><code>VariantPart   = CASE { ['|'] [INLINE] identdef ':' type }</code></pre>
<pre><code>IdentList  = identdef { [','] identdef }</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14602">4.10</a></span><a href="#14283">&#x21B3;</a>
<pre><code>PointerType = ( POINTER TO | '^' ) type</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14603">4.11</a></span><a href="#14289">&#x21B3;</a>
<pre><code>ProcedureType = PROCEDURE [FormalParameters]</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14604">4.12</a></span><a href="#14294">&#x21B3;</a>
<pre><code>enumeration ::= '(' constEnum ')' <br />constEnum ::= ident [ '=' ConstExpression ] { [','] ident } </code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14605">4.13</a></span><a href="#14301">&#x21B3;</a>
<pre><code>VariableDeclaration = IdentList ':' type</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14606">4.14</a></span><a href="#14309">&#x21B3;</a>
<pre><code>designator = qualident {selector}</code></pre>
<pre><code>selector   = '.' ident | '[' expression ']' | '^' | '(' qualident ')'</code></pre>
<pre><code>ExpList    = expression {[','] expression}</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14607">4.15</a></span><a href="#14321">&#x21B3;</a>
<pre><code>expression       = SimpleExpression [ relation SimpleExpression ]</code></pre>
<pre><code>relation         = '=' | '#' | '&lt;' | '&lt;=' | '&gt;' | '&gt;=' | IN</code></pre>
<pre><code>SimpleExpression = ['+' | '-'] term { AddOperator term }</code></pre>
<pre><code>AddOperator      = '+' | '-' | OR</code></pre>
<pre><code>term             = factor {MulOperator factor}</code></pre>
<pre><code>MulOperator      = '*' | '/' | DIV | MOD | '&amp;' | AND</code></pre>
<pre><code>literal          = number | string | hexstring | hexchar</code></pre>
<pre><code>                   | NIL | TRUE | FALSE | set</code></pre>
<pre><code>constructor      = NamedType '{' [ component {',' component} ] '}'</code></pre>
<pre><code>component        = ConstExpression</code></pre>
<pre><code>factor           = literal | designator [ActualParameters]</code></pre>
<pre><code>	       | '(' expression ')' | ('~'|NOT) factor</code></pre>
<pre><code>	       | '@' designator | constructor</code></pre>
<pre><code>ActualParameters = '(' [ ExpList ] ')'</code></pre>
<pre><code>set              = '{' [ element {[','] element} ] '}'</code></pre>
<pre><code>element          = expression ['..' expression]</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14608">4.16</a></span><a href="#14352">&#x21B3;</a>
<pre><code>FunctionCall           = designator ActualParameters</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="17797">4.17</a></span><a href="#17796">&#x21B3;</a>
<code>constructor = [NamedType] '{' [ component {[','] component} ] '}' </code>
<br><code>component = ident ':' expression </code>
<br><code>	| '[' ConstExpression ']' ':' expression </code>
<br><code>	| expression ['..' expression] </code></div>
<div style="margin-left:27px"><span class="label"><a name="16067">4.18</a></span><a href="#16062">&#x21B3;</a>
<pre><code>hexstring = '$' {hexDigit} '$'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14609">4.19</a></span><a href="#14358">&#x21B3;</a>
<pre><code>statement = [ assignment | ProcedureCall | IfStatement</code></pre>
<pre><code>            | CaseStatement  | WithStatement | LoopStatement</code></pre>
<pre><code>            | ExitStatement | GotoStatement | gotoLabel </code></pre>
<pre><code>	| ReturnStatement | RepeatStatement | ForStatement ]</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14610">4.20</a></span><a href="#14362">&#x21B3;</a>
<pre><code>StatementSequence = statement { [&quot;;&quot;] statement} </code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14611">4.21</a></span><a href="#14366">&#x21B3;</a>
<pre><code>assignment = designator ':=' expression</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14612">4.22</a></span><a href="#14378">&#x21B3;</a>
<pre><code>ProcedureCall = designator [ ActualParameters ]</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14613">4.23</a></span><a href="#14384">&#x21B3;</a>
<pre><code>IfStatement    = IF expression THEN StatementSequence</code></pre>
<pre><code>	     {ElsifStatement} [ElseStatement] END</code></pre>
<pre><code>ElsifStatement = ELSIF expression THEN StatementSequence</code></pre>
<pre><code>ElseStatement  = ELSE StatementSequence</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14614">4.24</a></span><a href="#14390">&#x21B3;</a>
<pre><code>CaseStatement = CASE expression OF ['|'] Case { '|' Case }</code></pre>
<pre><code>	    [ ELSE StatementSequence ] END</code></pre>
<pre><code>Case          = [ CaseLabelList ':' StatementSequence ]</code></pre>
<pre><code>CaseLabelList = LabelRange { [','] LabelRange }</code></pre>
<pre><code>LabelRange    = label [ '..' label ]</code></pre>
<pre><code>label         = ConstExpression</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14615">4.25</a></span><a href="#14396">&#x21B3;</a>
<pre><code>WhileStatement = WHILE expression DO StatementSequence END</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14616">4.26</a></span><a href="#14403">&#x21B3;</a>
<pre><code>RepeatStatement = REPEAT StatementSequence UNTIL expression</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14617">4.27</a></span><a href="#14407">&#x21B3;</a>
<pre><code>ForStatement = FOR ident ':=' expression TO expression</code></pre>
<pre><code>	   [BY ConstExpression]</code></pre>
<pre><code>	   DO StatementSequence END</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14618">4.28</a></span><a href="#14418">&#x21B3;</a>
<pre><code>LoopStatement = LOOP StatementSequence END</code></pre>
<pre><code>ExitStatement = EXIT</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14619">4.29</a></span><a href="#14428">&#x21B3;</a>
<pre><code>ReturnStatement = RETURN [ expression ]</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14620">4.30</a></span><a href="#14430">&#x21B3;</a>
<pre><code>ExitStatement   = EXIT</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14621">4.31</a></span><a href="#14433">&#x21B3;</a>
<pre><code>GotoStatement = 'GOTO' ident</code></pre>
<pre><code>gotoLabel = ident ':'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14622">4.32</a></span><a href="#14457">&#x21B3;</a>
<pre><code>ProcedureDeclaration = ProcedureHeading ( [ INLINE | INVAR ] [';'] ProcedureBody <br />                                        | [';'] EXTERN [ident] ) <br />                       | ( PROCEDURE | PROC ) '^' identdef [ FormalParameters ]<br />                                        [ INLINE | INVAR | EXTERN ]<br />                       | ( PROCEDURE | PROC ) identdef '=' qualident<br /><br />ProcedureHeading     = ( PROCEDURE | PROC ) identdef [ FormalParameters ]<br /><br />ProcedureBody        = DeclarationSequence BEGIN StatementSequence END ident</code></pre>
<pre><code>DeclarationSequence  = { CONST { ConstDeclaration [';'] }</code></pre>
<pre><code>	           | TypeDeclarationSection</code></pre>
<pre><code>	           | VAR { VariableDeclaration [';'] }</code></pre>
<pre><code>	           | ProcedureDeclaration [';'] }<br /><br />TypeDeclarationSection = TYPE { TypeDeclaration [';'] }</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14623">4.33</a></span><a href="#14489">&#x21B3;</a>
<pre><code>FormalParameters = '(' [ FPSection { [';'] FPSection } [ [';'] '..'] ] ')'</code></pre>
<pre><code>                   [ ':' ReturnType ]</code></pre>
<pre><code>ReturnType       = [ POINTER TO | '^' ] NamedType</code></pre>
<pre><code>FPSection        = [CONST] ident { [','] ident } ':' FormalType</code></pre>
<pre><code>FormalType       = type</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14624">4.34</a></span><a href="#14501">&#x21B3;</a>
<pre><code>module     = MODULE ident [ MetaParams ] [';']</code></pre>
<pre><code>             { ImportList | DeclarationSequence }</code></pre>
<pre><code>	 [ BEGIN StatementSequence ] END ident ['.']</code></pre>
<pre><code>ImportList = IMPORT import { [','] import } [';']</code></pre>
<pre><code>import     = [ ident ':=' ] ImportPath ident [ MetaActuals ]</code></pre>
<pre><code>ImportPath = { ident '.' }</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14625">4.35</a></span><a href="#14512">&#x21B3;</a>
<pre><code>MetaParams       = '(' MetaSection { [';'] MetaSection } ')'</code></pre>
<pre><code>MetaSection      = ['CONST' | 'TYPE'] ident { [','] ident } [ ':' NamedType ]<br />ConstDeclaration = identdef ':' NamedType</code></pre>
<pre><code>TypeConstraint   = NamedType</code></pre>
<pre><code>MetaActuals      = '(' ConstExpression { [','] ConstExpression } ')'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14626">4.36</a></span><a href="#14519">&#x21B3;</a>
<pre><code>directive = '&lt;*' ident ( '+' | '-' ) '*&gt;'</code></pre></div>
<div style="margin-left:27px"><span class="label"><a name="14627">4.37</a></span><a href="#14528">&#x21B3;</a>
<pre><code>directive  = '&lt;*' [ scIf | scElsif | scElse | scEnd ] '*&gt;'</code></pre>
<pre><code>scIf       = IF scExpr THEN</code></pre>
<pre><code>scElsif    = ELSIF condition THEN</code></pre>
<pre><code>scElse     = ELSE</code></pre>
<pre><code>scEnd      = END</code></pre>
<pre><code>condition  = scTerm { OR scTerm }</code></pre>
<pre><code>scTerm     = scFactor {'&amp;' scFactor}</code></pre>
<pre><code>scFactor   = ident | '(' condition ')' | '~' scFactor</code></pre></div>
<h4 style="margin-left:9px"><span class="label"><a name="14650">5</a></span>
Predeclared Types</h4>
<div style="margin-left:27px"><span class="label"><a name="14653">5.1</a></span>
<b>ANY</b></div>
<div style="margin-left:45px"><span class="label"><a name="14690">5.1.1</a></span>
Opaque type only usable as a pointer base type which is assignment compatible with all pointer types, like void* in C.</div>
<div style="margin-left:27px"><span class="label"><a name="14684">5.2</a></span>
<b>BOOLEAN</b></div>
<div style="margin-left:45px"><span class="label"><a name="14685">5.2.1</a></span>
see <a href="#14224">2.6.4 Basic types</a>.</div>
<div style="margin-left:27px"><span class="label"><a name="14678">5.3</a></span>
<b>BYTE, UINT8, UINT16, UINT32, UINT64</b></div>
<div style="margin-left:45px"><span class="label"><a name="14679">5.3.1</a></span>
Unsigned integer types, see <a href="#14224">2.6.4 Basic types</a>.</div>
<div style="margin-left:27px"><span class="label"><a name="14686">5.4</a></span>
<b>CHAR</b></div>
<div style="margin-left:45px"><span class="label"><a name="14687">5.4.1</a></span>
see <a href="#14224">2.6.4 Basic types</a>.</div>
<div style="margin-left:27px"><span class="label"><a name="14676">5.5</a></span>
<b>INT8, INT16, INT32, INT64, SHORTINT, INTEGER, LONGINT</b></div>
<div style="margin-left:45px"><span class="label"><a name="14677">5.5.1</a></span>
Signed integer types, see <a href="#14224">2.6.4 Basic types</a>.</div>
<div style="margin-left:27px"><span class="label"><a name="14680">5.6</a></span>
<b>REAL, LONGREAL, F32, F64</b></div>
<div style="margin-left:45px"><span class="label"><a name="14681">5.6.1</a></span>
Floating-point types, see <a href="#14224">2.6.4 Basic types</a>.</div>
<div style="margin-left:27px"><span class="label"><a name="14688">5.7</a></span>
<b>SET</b></div>
<div style="margin-left:45px"><span class="label"><a name="14689">5.7.1</a></span>
see <a href="#14224">2.6.4 Basic types</a>.</div>
<div style="margin-left:27px"><span class="label"><a name="14651">5.8</a></span>
<b>VA_LIST</b></div>
<div style="margin-left:45px"><span class="label"><a name="14683">5.8.1</a></span>
Opaque type representing the list of variable parameters, see <a href="#14458">2.11.12 Formal parameters</a>.</div>
<h4 style="margin-left:9px"><span class="label"><a name="14136">6</a></span>
<b>Predeclared Procedure Reference</b></h4>
<h4 style="margin-left:27px"><span class="label"><a name="14775">6.1</a></span>
Predeclared function procedures</h4>
<div style="margin-left:45px"><span class="label"><a name="14825">6.1.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 ><thead>
<tr>
<td>
<b>Name</b></td>
<td>
<br><b>Argument type</b></td>
<td>
<br><b>Result type</b></td>
<td>
<br><b>Function</b></td></tr></thead>
<tr>
<td>
<br>ABS(x)</td>
<td>
<br>numeric type</td>
<td>
<br>type of x</td>
<td>
<br>absolute value</td></tr>
<tr>
<td>
<br>CAP(x)</td>
<td>
<br>CHAR</td>
<td>
<br>CHAR</td>
<td>
<br>corresponding capital letter (only for the ASCII subset of the CHAR type)</td></tr>
<tr>
<td>
<br>BITAND(x,y)</td>
<td>
<br>x, y: UINT32 or UINT64</td>
<td>
<br>UINT32 or UINT64</td>
<td>
<br>bitwise AND; result is UINT64 if x or y is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>BITASR(x,n)</td>
<td>
<br>x: UINT32 or UINT64, n: UINT32</td>
<td>
<br>UINT32 or UINT64</td>
<td>
<br>arithmetic shift right by n bits, where n &gt;= 0 and n &lt; SIZE(x)*8; result is UINT64 if x is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>BITNOT(x)</td>
<td>
<br>x: UINT32 or UINT64</td>
<td>
<br>UNT32 or UINT64</td>
<td>
<br>bitwise NOT; result is UINT64 if x or y is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>BITOR(x,y)</td>
<td>
<br>x, y: UINT32 or UINT64</td>
<td>
<br>UINT32 or UINT64</td>
<td>
<br>bitwise OR; result is UINT64 if x or y is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>BITS(x)</td>
<td>
<br>x: UINT32</td>
<td>
<br>SET</td>
<td>
<br>set corresponding to the integer; the first element corresponds to the least significant digit of the integer and the last element to the most significant digit.</td></tr>
<tr>
<td>
<br>BITSHL(x,n)</td>
<td>
<br>x: UINT32 or UINT64, n: UINT32</td>
<td>
<br>UINT32 or UINT64</td>
<td>
<br>logical shift left by n bits, where n &gt;= 0 and n &lt; SIZE(x)*8; result is UINT64 if x is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>BITSHR(x,n)</td>
<td>
<br>x: UINT32 or UINT64, n: UINT32</td>
<td>
<br>UINT32 or UINT64</td>
<td>
<br>logical shift right by n bits, where n &gt;= 0 and n &lt; SIZE(x)*8; result is UINT64 if x is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>BITXOR(x,y)</td>
<td>
<br>x, y: UINT32 or UINT64</td>
<td>
<br>UINT32 or UINT64</td>
<td>
<br>bitwise XOR; result is UINT64 if x or y is UINT64, else UINT32</td></tr>
<tr>
<td>
<br>CAST(T,x)</td>
<td>
<br>T:enumeration type x:ordinal number</td>
<td>
<br>enumeration type</td>
<td>
<br>the enum item with the ordinal number x; halt if no match</td></tr>
<tr>
<td></td>
<td>
<br>T,x: integer type</td>
<td>
<br>T</td>
<td>
<br>convert integer types, accept possible loss of information</td></tr>
<tr>
<td>
<br>CHR(x)</td>
<td>
<br>integer type</td>
<td>
<br>CHAR</td>
<td>
<br>Latin-1 character with ordinal number x</td></tr>
<tr>
<td>
<br>DEFAULT(T)</td>
<td>
<br>T = basic type</td>
<td>
<br>T</td>
<td>
<br>zero for numeric and character types, false for boolean, empty set</td></tr>
<tr>
<td></td>
<td>
<br>T = enumeration type</td>
<td>
<br>T</td>
<td>
<br>same as MIN(T)</td></tr>
<tr>
<td></td>
<td>
<br>T = pointer/proc type</td>
<td>
<br>T</td>
<td>
<br>nil</td></tr>
<tr>
<td></td>
<td>
<br>T = record/array type</td>
<td>
<br>T</td>
<td>
<br>all fields/elements set to their DEFAULT type</td></tr>
<tr>
<td>
<br>FLOOR(x)</td>
<td>
<br>x: REAL or LONGREAL</td>
<td>
<br>INT32 or INT64</td>
<td>
<br>largest integer not greater than x; result is INT64 if x is LONGREAL, else INT32</td></tr>
<tr>
<td>
<br>FLT(x)</td>
<td>
<br>x: INT32 or INT64</td>
<td>
<br>REAL or LONGREAL</td>
<td>
<br>Convert integer to real type; result is LONGREAL if x was INT64, else REAL, accepting potential loss of information</td></tr>
<tr>
<td></td>
<td>
<br>x: UINT32 or UINT64</td>
<td>
<br>REAL or LONGREAL</td>
<td>
<br>Convert integer to real type; result is LONGREAL if x was UINT64, else REAL, accepting potential loss of information</td></tr>
<tr>
<td>
<br>GETENV(T,n)</td>
<td>
<br>T: basic, enumeration or char array type</td>
<td>
<br>T</td>
<td>
<br>get the value of the environment variable with name n or the default value</td></tr>
<tr>
<td></td>
<td>
<br>n: name string</td>
<td></td>
<td></td></tr>
<tr>
<td>
<br>GETENV(T,n,d)</td>
<td>
<br>d: default of T</td>
<td>
<br>T</td>
<td>
<br>like GETENV(T,n), but with explicit default value if not set</td></tr>
<tr>
<td>
<br>LEN(v)</td>
<td>
<br>v: non-open array</td>
<td>
<br>UINT32</td>
<td>
<br>length of array v</td></tr>
<tr>
<td>
<br>LONG(x)</td>
<td>
<br>x: INT8 or UINT8</td>
<td>
<br>INT16 or UINT16</td>
<td>
<br>identity</td></tr>
<tr>
<td></td>
<td>
<br>x: INT16 or UINT16</td>
<td>
<br>INT32 or UINT32</td>
<td></td></tr>
<tr>
<td></td>
<td>
<br>x: INT32 or UINT32</td>
<td>
<br>INT64 or UINT64</td>
<td></td></tr>
<tr>
<td></td>
<td>
<br>x: REAL</td>
<td>
<br>LONGREAL</td>
<td></td></tr>
<tr>
<td>
<br>MAX(T)</td>
<td>
<br>T = basic type</td>
<td>
<br>T</td>
<td>
<br>maximum value of type T</td></tr>
<tr>
<td></td>
<td>
<br>T = SET</td>
<td>
<br>INT32</td>
<td>
<br>maximum element of a set</td></tr>
<tr>
<td></td>
<td>
<br>T = enumeration type</td>
<td>
<br>T</td>
<td>
<br>last element of the enumeration</td></tr>
<tr>
<td>
<br>MAX(x,y)</td>
<td>
<br>x,y: numeric type</td>
<td>
<br>numeric type</td>
<td>
<br>greater of x and y, returns smallest numeric type including both arguments</td></tr>
<tr>
<td></td>
<td>
<br>x,y: character type</td>
<td>
<br>character type</td>
<td>
<br>greater of x and y, returns smallest character type including both arguments</td></tr>
<tr>
<td>
<br>MIN(T)</td>
<td>
<br>T = basic type</td>
<td>
<br>T</td>
<td>
<br>minimum value of type T</td></tr>
<tr>
<td></td>
<td>
<br>T = SET</td>
<td>
<br>UINT32</td>
<td>
<br>0</td></tr>
<tr>
<td></td>
<td>
<br>T = enumeration type</td>
<td>
<br>T</td>
<td>
<br>first element of the enumeration</td></tr>
<tr>
<td>
<br>MIN(x,y)</td>
<td>
<br>x,y: numeric type</td>
<td>
<br>numeric type</td>
<td>
<br>smaller of x and y, returns smallest numeric type including both arguments</td></tr>
<tr>
<td></td>
<td>
<br>x,y: character type</td>
<td>
<br>character type</td>
<td>
<br>smaller of x and y, returns smallest character type including both arguments</td></tr>
<tr>
<td>
<br>ODD(x)</td>
<td>
<br>integer type</td>
<td>
<br>BOOLEAN</td>
<td>
<br>x MOD 2 = 1</td></tr>
<tr>
<td>
<br>ORD(x)</td>
<td>
<br>x: CHAR</td>
<td>
<br>BYTE</td>
<td>
<br>ordinal number of x</td></tr>
<tr>
<td></td>
<td>
<br>x: enumeration type</td>
<td>
<br>UINT32</td>
<td>
<br>ordinal number of the given identifier</td></tr>
<tr>
<td></td>
<td>
<br>x: BOOLEAN</td>
<td>
<br>BYTE</td>
<td>
<br>TRUE = 1, FALSE = 0</td></tr>
<tr>
<td></td>
<td>
<br>x: set type</td>
<td>
<br>UINT32</td>
<td>
<br>number representing the set; the first element corresponds to the least significant digit of the number and the last element to the most significant digit.</td></tr>
<tr>
<td>
<br>SHORT(x)</td>
<td>
<br>x: INT64 or UINT64</td>
<td>
<br>INT32 or UINT32</td>
<td>
<br>identity</td></tr>
<tr>
<td></td>
<td>
<br>x: INT32 or UINT32</td>
<td>
<br>INT16 or UINT16</td>
<td>
<br>identity</td></tr>
<tr>
<td></td>
<td>
<br>x: INT16 or UINT16</td>
<td>
<br>INT8 or UINT8</td>
<td>
<br>identity</td></tr>
<tr>
<td></td>
<td>
<br>x: LONGREAL</td>
<td>
<br>REAL</td>
<td>
<br>identity (truncation possible)</td></tr>
<tr>
<td>
<br>SIGNED(x)</td>
<td>
<br>x: unsigned integer T</td>
<td>
<br>signed integer T</td>
<td>
<br>interprets the raw bytes of x as signed integer of the same byte width</td></tr>
<tr>
<td>
<br>SIZE(T)</td>
<td>
<br>any type</td>
<td>
<br>UINT32</td>
<td>
<br>number of bytes required by T</td></tr>
<tr>
<td>
<br>STRLEN(s)</td>
<td>
<br>s: array of char</td>
<td>
<br>UINT32</td>
<td>
<br>dynamic length of the string up to and not including the terminating 0X</td></tr>
<tr>
<td></td>
<td>
<br>s: string literal</td>
<td></td>
<td></td></tr>
<tr>
<td>
<br>UNSIGNED(x)</td>
<td>
<br>x: signed integer T</td>
<td>
<br>unsigned integer T</td>
<td>
<br>interprets the raw bytes of x as unsigned integer of the same byte width</td></tr>
<tr>
<td>
<br>VARARG(T,n)</td>
<td>
<br>T: target type, n: argument number</td>
<td>
<br>value of type T</td>
<td>
<br>Returns the value of the nth variable argument. Only valid in a function declared with variable arguments.</td></tr>
<tr>
<td>
<br>VARARG(v,T,n)</td>
<td>
<br>v: VA_LIST, T: target type, n: argument number</td>
<td>
<br>value of type T</td>
<td>
<br>Returns the value of the nth variable argument of the VA_LIST. Can be used in procedures with a VA_LIST formal parameter.</td></tr>
<tr>
<td>
<br>VARARGS()</td>
<td></td>
<td>
<br>VA_LIST</td>
<td>
<br>Returns an opaque value of the built-in type VA_LIST which can be passed as argument to another procedure. Only valid in a function declared with variable arguments.</td></tr></table></div>
<h4 style="margin-left:27px"><span class="label"><a name="14777">6.2</a></span>
Predeclared proper procedures</h4>
<div style="margin-left:45px"><span class="label"><a name="15971">6.2.1</a></span>
<table border=1 cellspacing=0 CELLPADDING=3 ><thead>
<tr>
<td>
<b>Name</b></td>
<td>
<br><b>Argument types</b></td>
<td>
<br><b>Function</b></td></tr></thead>
<tr>
<td>
<br>ASSERT(x)</td>
<td>
<br>x: Boolean expression</td>
<td>
<br>terminate program execution if not x</td></tr>
<tr>
<td>
<br>ASSERT(x, n)</td>
<td>
<br>x: Boolean expression</td>
<td>
<br>terminate program execution if not x</td></tr>
<tr>
<td></td>
<td>
<br>n: integer constant</td>
<td></td></tr>
<tr>
<td>
<br>DEC(v)</td>
<td>
<br>integer type</td>
<td>
<br>v := v - 1</td></tr>
<tr>
<td></td>
<td>
<br>const enumeration type</td>
<td>
<br>previous ident in enumeration</td></tr>
<tr>
<td></td>
<td>
<br>pointer to T</td>
<td>
<br>decrement address by size of T</td></tr>
<tr>
<td>
<br>DEC(v, n)</td>
<td>
<br>v, n: integer type</td>
<td>
<br>v := v - n</td></tr>
<tr>
<td></td>
<td>
<br>v: pointer to T</td>
<td>
<br>decrement address by n times size of T</td></tr>
<tr>
<td>
<br>DISPOSE(p)</td>
<td>
<br>p: pointer</td>
<td>
<br>free the memory allocated before using NEW()</td></tr>
<tr>
<td>
<br>EXCL(v, x)</td>
<td>
<br>v: SET; x: integer type</td>
<td>
<br>v := v - {x}</td></tr>
<tr>
<td>
<br>HALT(n)</td>
<td>
<br>integer constant</td>
<td>
<br>terminate program execution</td></tr>
<tr>
<td>
<br>INC(v)</td>
<td>
<br>integer type</td>
<td>
<br>v := v + 1</td></tr>
<tr>
<td></td>
<td>
<br>const enumeration type</td>
<td>
<br>next ident in enumeration</td></tr>
<tr>
<td></td>
<td>
<br>pointer to T</td>
<td>
<br>increment address by size of T</td></tr>
<tr>
<td>
<br>INC(v, n)</td>
<td>
<br>v, n: integer type</td>
<td>
<br>v := v + n</td></tr>
<tr>
<td></td>
<td>
<br>v: pointer to T</td>
<td>
<br>increment address by n times size of T</td></tr>
<tr>
<td>
<br>INCL(v, x)</td>
<td>
<br>v: SET; x: integer type</td>
<td>
<br>v := v + {x}</td></tr>
<tr>
<td>
<br>NEW(p)</td>
<td>
<br>p: pointer to T</td>
<td>
<br>allocate p^ of type T</td></tr>
<tr>
<td>
<br>NEW(p,n)</td>
<td>
<br>p: pointer to open array</td>
<td>
<br>allocate p^ with length n</td></tr>
<tr>
<td></td>
<td>
<br>x: integer type</td>
<td></td></tr>
<tr>
<td>
<br>PCALL(e,p,a<sub>0</sub>,…​,a<sub>n</sub>)</td>
<td>
<br>e: POINTER TO ANY; p: proper procedure type; a<sub>i</sub>: actual parameters</td>
<td>
<br>call procedure type p with arguments a<sub>0</sub>…​a<sub>n</sub> corresponding to the parameter list of p; e is set to nil in the normal case, and to the pointer passed to RAISE() otherwise</td></tr>
<tr>
<td>
<br>PRINT(a)</td>
<td>
<br>a: basic type, string or char array</td>
<td>
<br>prints the argument to standard output, not terminating the line; for debugging and logging purpose only</td></tr>
<tr>
<td>
<br>PRINTLN(a)</td>
<td>
<br>a: basic type, string or char array</td>
<td>
<br>prints the argument to the standard output and terminates the line; for debugging and logging purpose only</td></tr>
<tr>
<td>
<br>RAISE(e)</td>
<td>
<br>e: POINTER TO ANY</td>
<td>
<br>terminates the last protected function called and returns e as the exception value; RAISE() never returns</td></tr>
<tr>
<td>
<br>SETENV(n,v)</td>
<td>
<br>n: name string, v: basic or const enum type or array of char</td>
<td>
<br>set the environment value</td></tr></table></div>
<h4 style="margin-left:9px"><span class="label"><a name="14628">7</a></span>
References</h4>
<div style="margin-left:27px"><span class="label"><a name="14630">7.1</a></span><span class="ident">[Mo91]</span>
Mössenböck, H.; Wirth, N. (1991). The Programming Language Oberon-2. Structured Programming, 12(4):179-195, 1991. <a href="http://www.ssw.uni-linz.ac.at/Research/Papers/Oberon2.pdf"><u>http://www.ssw.uni-linz.ac.at/Research/Papers/Oberon2.pdf</u></a> (accessed 2020-11-16).</div>
<div style="margin-left:27px"><span class="label"><a name="14629">7.2</a></span><span class="ident">[Oak95]</span>
Kirk, B. et al. (1995). The Oakwood Guidelines for Oberon-2 Compiler Developers. Revision 1A. <a href="https://web.archive.org/web/20171226172235/https://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf"><u>https://web.archive.org/web/20171226172235/https://www.math.bas.bg/bantchev/place/oberon/oakwood-guidelines.pdf</u></a> (accessed 2022-04-26).</div>
<div style="margin-left:27px"><span class="label"><a name="14631">7.3</a></span><span class="ident">[OBX]</span>
Keller, R. (2021): The Programming Language Oberon+, <a href="https://github.com/oberon-lang/specification/blob/master/The_Programming_Language_Oberon%2B.adoc"><u>github.com/.../The_Programming_Language_Oberon+.adoc</u></a> (accessed 2024-02-03).</div>
</body></html>