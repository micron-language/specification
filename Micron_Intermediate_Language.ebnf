// Copyright (c) 2024 by Rochus Keller <mailto:me@rochus-keller.ch>
// 
// GNU General Public License Usage
// This file may be used under the terms of the GNU General Public
// License (GPL) versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the file LICENSE.GPL included in
// the packaging of this file. Please review the following information
// to ensure GNU General Public Licensing requirements will be met:
// http://www.fsf.org/licensing/licenses/info/GPLv2.html and
// http://www.gnu.org/copyleft/gpl.html.


Mil ::= module


ident ::= // ( letter | '_' | '$' ) {letter | digit | '_' | '$'}

unsigned ::= // digit {digit} | digit {hexDigit} 'H'

integer ::= ['+'|'-'] unsigned

real ::= // digit {digit} '.' {digit} ['E' ['+' | '-'] digit {digit}]

string ::= // '"' {character} '"' 

hexstring ::=
hexstringdelim- ::= '#'

comment- ::= '(*' '*)' '//'
Comment ::=

qualident ::= [\LA: 1:ident & 2:'.'\ ImportPath ident '.'] ident
identdef  ::= ident ['*']

TypeDeclaration ::= identdef '=' type
type            ::= ArrayType | StructUnionType | PointerType | ProcedureType | NamedType
NamedType       ::= qualident

ArrayType  ::= 'ARRAY' [ length ] 'OF' NamedType | '[' [ length ] ']' NamedType
length     ::= unsigned


StructUnionType ::= ('STRUCT' | 'UNION') { \LA: 1:!'END'\ FieldList [';'] } 'END'
FieldList  ::= IdentList ':' NamedType
IdentList  ::= identdef { [','] identdef }

PointerType ::= ( 'POINTER' 'TO' | '^' ) NamedType

ProcedureType ::= ('PROCEDURE'|'PROC') [FormalParameters]

VariableDeclaration ::= IdentList ':' NamedType

ProcedureDeclaration ::= ( 'PROCEDURE' | 'PROC' ) identdef  (
                       [ FormalParameters ] ( ['INLINE'|'INVAR'|'INIT'] [ ';' ] ProcedureBody  | \LL:2\ [ ';' ] 'EXTERN' [ident] )
                       | '=' qualident )

ProcedureBody        ::= ['VAR' { \LA: 1:(ident&!'BEGIN')\ LocalDeclaration [';'] }] 
                                        'BEGIN' StatementSequence 'END' ident

LocalDeclaration     ::= IdentList ':' NamedType

FormalParameters ::= '(' [ FPSection { \LL:2\ ';' FPSection } [ ';' '..'] ] ')' [ ':' ReturnType ]
ReturnType       ::= NamedType
FPSection        ::= ident { [','] ident } ':' NamedType

module     ::= 'MODULE' ident [ MetaParams ] [';'] 
                        { ImportList | DeclarationSequence }
	                'END' ident ['.']
ImportList ::= 'IMPORT' import { [','] import } [';']
import     ::= [ \LL:2\ ident ':=' ] ImportPath ident [ MetaActuals ] 
ImportPath ::= { \LA: 1:ident&2:'.'\ ident '.' }

DeclarationSequence  ::= { 'TYPE' { \LA: 1:(ident&!('PROC'|'PROCEDURE'|'VAR'))\ TypeDeclaration [';'] }
	           | 'VAR' { \LA: 1:(ident&!('PROC'|'PROCEDURE'|'TYPE'))\ VariableDeclaration [';'] }
	           | ProcedureDeclaration [';'] }
	
Expression ::= { ExpInstr }

ExpInstr ::= 'ADD' | 'AND' | ('CALL' | 'CALLI') qualident | 'CASTPTR' qualident
                      | 'CEQ' | 'CGT' | 'CGT_UN' | 'CLT' | 'CLT_UN' 
                      | 'CONV_I1' | 'CONV_I2' | 'CONV_I4' | 'CONV_I8' | 'CONV_R4' | 'CONV_R8'
                      | 'CONV_U1' | 'CONV_U2' | 'CONV_U4' | 'CONV_U8' | 'CONV_IP'
                      | 'DIV' | 'DIV_UN' | 'DUP' | 'INITOBJ' qualident | ('LDARG'|'LDARG_S') (unsigned|ident) 
                      | 'LDARG_0' | 'LDARG_1' | 'LDARG_2' | 'LDARG_3'
                      | ('LDARGA'|'LDARGA_S') (unsigned|ident)
                      | ('LDC_I4'|'LDC_I8'|'LDC_I4_S') integer | ('LDC_R4'|'LDC_R8') real
                      | 'LDC_I4_0' | 'LDC_I4_1' | 'LDC_I4_2' | 'LDC_I4_3' | 'LDC_I4_4' | 'LDC_I4_5'
                      | 'LDC_I4_6' | 'LDC_I4_7' | 'LDC_I4_8' | 'LDC_I4_M1' | 'LDC_OBJ' constructor
                      | ('LDELEM'|'LDELEMA') qualident | 'LDELEM_I1' | 'LDELEM_I2'
                      | 'LDELEM_I4' | 'LDELEM_I8' | 'LDELEM_U1' | 'LDELEM_U2' 
                      | 'LDELEM_U4' | 'LDELEM_U8' | 'LDELEM_R4' | 'LDELEM_R8' | 'LDELEM_IP'
                      | ('LDFLD'|'LDFLDA') qualident '.' ident | 'LDFTN' qualident
                      | 'LDIND_I1' | 'LDIND_I2' | 'LDIND_I4' | 'LDIND_I8' | 'LDIND_U1' | 'LDIND_U2'
                      | 'LDIND_U4' | 'LDIND_R4' | 'LDIND_U8' | 'LDIND_R8' | 'LDIND_IP'
                      | ('LDLOC'|'LDLOC_S'|'LDLOCA'|'LDLOCA_S')(unsigned|ident)
                      | 'LDLOC_0' | 'LDLOC_1' | 'LDLOC_2' | 'LDLOC_3' | 'LDNULL' 
                      | 'LDOBJ' qualident | 'LDPROC' qualident | 'LDSTR' string
                      | ('LDVAR'|'LDVARA') qualident | 'MUL' | 'NEG' 
                      | ('NEWARR'|'NEWVLA'|'NEWOBJ') qualident 
                      | 'NOT' | 'OR' | 'REM' | 'REM_UN' | 'SHL' | 'SHR' | 'SHR_UN' | 'SUB' | 'XOR'

StatementSequence ::= { Statement }
          
Statement ::=  ('CALL' | 'CALLI') qualident | 'DISP' | RepeatUntil 
                         | 'EXIT' | 'GOTO' ident | IfThenElse
                         | 'LABEL' ident | 'LINE' unsigned | Loop | 'POP' | 'RET' 
                         | ('STARG'|'STARG_S') (unsigned|ident)
                         | 'STELEM' qualident | 'STELEM_I1' | 'STELEM_I2' | 'STELEM_I4' | 'STELEM_I8' 
                         | 'STELEM_R4' | 'STELEM_R8' | 'STELEM_IP'
                         | 'STFLD' qualident '.' ident
                         | 'STIND_I1' | 'STIND_I2' | 'STIND_I4' | 'STIND_I8' | 'STIND_R4' | 'STIND_R8' | 'STIND_IP'
                         | ('STLOC' |'STLOC_S') (unsigned|ident) | 'STLOC_0' | 'STLOC_1' | 'STLOC_2' | 'STLOC_3'
                         | 'STOBJ' qualident | 'STVAR' qualident '.' ident | Switch | WhileDo

IfThenElse ::= 'IF' Expression 'THEN' StatementSequence [ 'ELSE' StatementSequence ] 'END'
Loop ::= 'LOOP' StatementSequence 'END'
Switch ::= 'SWITCH' Expression 
                 { 'CASE' integer { [','] integer }
                    'THEN' StatementSequence } 
                  [ 'ELSE' StatementSequence ] 'END'
RepeatUntil ::= 'REPEAT' StatementSequence 'UNTIL' Expression 'END'
WhileDo ::= 'WHILE' Expression 'DO' StatementSequence 'END'

MetaActuals ::= '(' ConstExpression { [','] ConstExpression } ')' 

MetaParams ::= '(' MetaSection { [';'] MetaSection } ')'

MetaSection ::= 'CONST' ident { \LL:2\ [','] ident } ':' NamedType | [ 'TYPE' ] ident { \LL:2\ [','] ident }

ConstExpression  ::= qualident | integer | real | string | hexstring

constructor ::= NamedType component_list
component_list ::= '{' [ component {[','] component} ] '}' 
component ::= [\LL:2\ ident '='] ( ConstExpression | component_list )

/// Pragmas
%module ::= 'Micron'
%namespace ::= 'Mil'
%suppress ::= ';' ',' '.' ':'

//%no_syntree ::= 'true'
%pseudo_keywords ::= 'true' 
