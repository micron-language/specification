// Copyright (c) 2024 by Rochus Keller <mailto:me@rochus-keller.ch>
// 
// GNU General Public License Usage
// This file may be used under the terms of the GNU General Public
// License (GPL) versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the file LICENSE.GPL included in
// the packaging of this file. Please review the following information
// to ensure GNU General Public Licensing requirements will be met:
// http://www.fsf.org/licensing/licenses/info/GPLv2.html and
// http://www.gnu.org/copyleft/gpl.html.


Mil ::= module


ident ::= // ( letter | '_' ) {letter | digit | '_' | '$'}

unsigned ::= // digit {digit} | digit {hexDigit} 'H'

integer ::= ['+'|'-'] unsigned

real ::= // digit {digit} '.' {digit} ['E' ['+' | '-'] digit {digit}]

string ::= // '"' {character} '"' 

hexstring ::=
hexstringdelim- ::= '$'

comment- ::= '(*' '*)' '//'
Comment ::=

qualident ::= [\LA: 1:ident & 2:'.'\ ident '.'] ident
identdef  ::= ident ['*']

TypeDeclaration ::= identdef '=' type
type            ::= NamedType | ArrayType | StructUnionType | PointerType | ProcedureType
NamedType       ::= qualident

ArrayType  ::= 'ARRAY' [ length ] 'OF' type | '[' [ length ] ']' type
length     ::= unsigned


StructUnionType ::= ('STRUCT' | 'UNION') { FieldList [';'] } 'END'
FieldList  ::= IdentList ':' type
IdentList  ::= identdef { [','] identdef }

PointerType ::= ( 'POINTER' 'TO' | '^' ) type

ProcedureType ::= ('PROCEDURE'|'PROC') [FormalParameters]

VariableDeclaration ::= IdentList ':' VariableType
VariableType ::= [ 'POINTER' 'TO' | '^' ] NamedType

ProcedureDeclaration ::= ProcedureHeading (
                       [ FormalParameters ] [';'] ProcedureBody 'END' [ ident ]
                       | '=' qualident )
ProcedureHeading     ::= ( 'PROCEDURE' | 'PROC' ) ['INLINE'] identdef 

ProcedureBody        ::= ['VAR' { LocalDeclaration [';'] }] 'BEGIN' StatementSequence

LocalDeclaration     ::= IdentList ':' VariableType

FormalParameters ::= '(' [ FPSection { \LL:2\ ';' FPSection } [ ';' '..'] ] ')' [ ':' ReturnType ]
ReturnType       ::= FormalType
FPSection        ::= ident { [','] ident } ':' FormalType
FormalType       ::= [ 'POINTER' 'TO' | '^' ] NamedType

module     ::= 'MODULE' ident [';'] [ImportList] { DeclarationSequence }
	               [ 'BEGIN' StatementSequence ] 'END' ident ['.']
ImportList ::= 'IMPORT' import { [','] import } [';']
import     ::= [ \LL:2\ ident ':=' ] ImportPath ident
ImportPath ::= { \LA: 1:ident&2:'.'\ ident '.' }

DeclarationSequence  ::= { 'TYPE' { TypeDeclaration [';'] }
	           | 'VAR' { VariableDeclaration [';'] }
	           | ProcedureDeclaration [';'] }
	
Expression ::= { ExpInstr }

ExpInstr ::= 'add' | 'and' | ('call' | 'calli') qualident | 'castptr' qualident
                      | 'ceq' | 'cgt' | 'cgt_un' | 'clt' | 'clt_un' 
                      | 'conv_i1' | 'conv_i2' | 'conv_i4' | 'conv_i8' | 'conv_r4' | 'conv_r8'
                      | 'conv_u1' | 'conv_u2' | 'conv_u4' | 'conv_u8' | 'conv_ip'
                      | 'div' | 'dup' | ('ldarg'|'ldarg_s') (unsigned|ident) 
                      | 'ldarg_0' | 'ldarg_1' | 'ldarg_2' | 'ldarg_3'
                      | ('ldarga'|'ldarga_s') (unsigned|ident)
                      | ('ldc_i4'|'ldc_i8'|'ldc_i4_s') integer | ('ldc_r4'|'ldc_r8') real
                      | 'ldc_i4_0' | 'ldc_i4_1' | 'ldc_i4_2' | 'ldc_i4_3' | 'ldc_i4_4' | 'ldc_i4_5'
                      | 'ldc_i4_6' | 'ldc_i4_7' | 'ldc_i4_8' | 'ldc_i4_m1'
                      | ('ldelem'|'ldelema') qualident | 'ldelem_i1' | 'ldelem_i2'
                      | 'ldelem_i4' | 'ldelem_i8' | 'ldelem_u1' | 'ldelem_u2' 
                      | 'ldelem_u4' | 'ldelem_u8' | 'ldelem_r4' | 'ldelem_r8' | 'ldelem_ip'
                      | ('ldfld'|'ldflda') qualident '.' ident | 'ldftn' qualident
                      | 'ldind_i1' | 'ldind_i2' | 'ldind_i4' | 'ldind_i8' | 'ldind_u1' | 'ldind_u2'
                      | 'ldind_u4' | 'ldind_r4' | 'ldind_u8' | 'ldind_r8' | 'ldind_ip'
                      | ('ldloc'|'ldloc_s'|'ldloca'|'ldloca_s')(unsigned|ident)
                      | 'ldloc_0' | 'ldloc_1' | 'ldloc_2' | 'ldloc_3' | 'ldnull' 
                      | 'ldobj' qualident | 'ldproc' qualident | 'ldstr' string
                      | ('ldvar'|'ldvara') qualident | 'mul' | 'neg' 
                      | ('newarr'|'newvla'|'newobj') qualident 
                      | 'not' | 'or' | 'rem' | 'shl' | 'shr' | 'shr_un' | 'sub' | 'xor'

StatementSequence ::= { Statement }
          
Statement ::= ('call' | 'calli') qualident | 'disp' | RepeatUntil 
                         | 'exit' | 'goto' ident | IfThenElse
                         | 'label' ident | 'line' unsigned | Loop | 'pop' | 'ret' 
                         | ('starg'|'starg_s') (unsigned|ident)
                         | 'stelem' qualident | 'stelem_i1' | 'stelem_i2' | 'stelem_i4' | 'stelem_i8' 
                         | 'stelem_r4' | 'stelem_r8' | 'stelem_ip'
                         | 'stfld' qualident '.' ident
                         | 'stind_i1' | 'stind_i2' | 'stind_i4' | 'stind_i8' | 'stind_r4' | 'stind_r8' | 'stind_ip'
                         | ('stloc' |'stloc_s') (unsigned|ident) | 'stloc_0' | 'stloc_1' | 'stloc_2' | 'stloc_3'
                         | 'stobj' qualident | 'stvar' qualident '.' ident | Switch | WhileDo

IfThenElse ::= 'IF' Expression 'THEN' StatementSequence [ 'ELSE' StatementSequence ] 'END'
Loop ::= 'LOOP' StatementSequence 'END'
Switch ::= 'SWITCH' Expression { 'CASE' Expression 'THEN' StatementSequence } 
                  [ 'ELSE' StatementSequence ] 'END'
RepeatUntil ::= 'REPEAT' StatementSequence 'UNTIL' Expression 'END'
WhileDo ::= 'WHILE' Expression 'DO' StatementSequence 'END'


/// Pragmas
%module ::= 'Mil'
%namespace ::= 'Mil'
%suppress ::= ';' ',' '.' ':'

%no_syntree ::= 'true'
%pseudo_keywords ::= 'true' 